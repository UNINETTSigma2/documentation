

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; Sigma2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/nris.css?v=69e7a171" />
      <link rel="stylesheet" type="text/css" href="../../_static/universal-navbar.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/statuspal.css" />

  
    <link rel="shortcut icon" href="../../_static/nris.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
      <script async="async" src="https://siteimproveanalytics.com/js/siteanalyze_6036825.js"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../../_static/statuspal_widget.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">
<!-- Send url to parent when displayed as iframe -->
<script>
    const valid_orign_url = "https://www.sigma2.no"
    window.addEventListener('message', function(event) {
        if (event.data === 'getDocumentationIframeUrl' && event.origin.startsWith(valid_orign_url)) {
            // path only (/path/example.html)
            const path = window.location.pathname
            // query string (including the initial ? symbol)
            const search = window.location.search
            // Returns the hash (including the initial # symbol)
            const hash = window.location.hash
            const newUrl = path + search + hash;
            event.source.postMessage(newUrl, event.origin)
        }
    })

</script>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Sigma2/NRIS documentation
              <img src="../../_static/NRIS Logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Policies</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../code-of-conduct.html">Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.sigma2.no/acceptable-use-policy">User Policy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/security-policy.html">Security policy for Sigma2 infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/sharing_files.html">Data handling and storage policy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software/licenses.html">Licence and access policies</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.sigma2.no/data-policy">Data Policy</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.sigma2.no/data-decommissioning-policies">Data decommissioning policies</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.sigma2.no/central-data-library-policy">Central Data Library Policy</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.sigma2.no/policies">Overview of Sigma2 Policies</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting help</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/support_line.html">Getting help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/extended_support.html">Extended support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/how_to_write_good_support_requests.html">Writing good support requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/qa-sessions.html">Open Question &amp; Answer Sessions for All Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/lost_forgotten_password.html">Lost, expiring or changing passwords</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/two_factor_authentication.html">One-time-pad (OTP) / Two-factor authentication</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.sigma2.no/project-leader-handbook">Project Leader Support</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Training</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../training/events.html">Training events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../training/notes_qa.html">Questions, Answers and Feedbacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../training/videos.html">Training Video Archives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../training/short_instructions.html">Short Instructions Video Archives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../training/material.html">Training materials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/opslog.html">Status and maintenance of systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/applying_account.html">How do I get an account?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/applying_resources.html">Applying for computing and storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/file_transfer.html">File transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/editing_files.html">Editing files</a></li>
<li class="toctree-l1"><a class="reference internal" href="vs_code/connect_to_server.html">Connecting to a system with Visual Studio Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/ssh.html">SSH</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/ssh.html#common-ssh-errors">Common SSH errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/ood.html">Open OnDemand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/R.html">First R calculation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data and Storage Services</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/nird/nird_dp.html">NIRD Data Peak</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/nird/nird_dl.html">NIRD Data Lake</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/nird/backup_lmd.html">NIRD Backup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/nird/cdl.html">(NIRD) Central Data Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nird_archive/user-guide.html">NIRD Research Data Archive (NIRD RDA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nird_service_platform/overview_nird_service_platform.html">NIRD Service Platform</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Storage Resources and Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/nird_lmd.html">NIRD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/clusters.html">Storage areas on HPC clusters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/quota.html">Storage quota</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/backup.html">Backup on Betzy, Saga, and NIRD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/performance.html">Optimizing storage performance</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">HPC usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/migration2metacenter.html">Migration to an NRIS HPC machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../computing/responsible-use.html">Using shared resources responsibly</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../jobs/overview.html">Running jobs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../jobs/internet-login-compute-nodes.html">Login nodes:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../jobs/internet-login-compute-nodes.html#compute-nodes">Compute nodes:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../computing/tuning-applications.html">Tuning applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides_llm.html">Running LLM Models in a Cluster Environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Compute resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/hardware_overview.html">Overview over our machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/betzy.html">Betzy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/olivia.html">Olivia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/saga.html">Saga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/lumi.html">LUMI</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Software</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../software/modulescheme.html">Software module scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software/installed_software.html">Installed software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software/userinstallsw.html">Installing software as user</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software/appguides.html">Application guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software/eessi.html">EESSI</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tools and Additional services</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../nird_toolkit/overview.html">NIRD Toolkit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/course_resources.html">CRaaS - Course Resources as a Service</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Code development and tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Code development and tutorials</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Sigma2/NRIS documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Introduction</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="introduction">
<span id="index-0"></span><span id="stencil"></span><h1>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h1>
<p><code class="docutils literal notranslate"><span class="pre">Divide-n-conquer</span></code> strategy is the foundation of parallel programming in which a bigger problem is divided into a set of smaller problems and solved efficiently. To design a generalized parallel programming model, which can fit a variety of problems, several methodologies were proposed around divide-n-conquer, and among them, one is Foster’s methodology. <a class="reference external" href="https://www.mcs.anl.gov/~itf/dbpp/text/node15.html">PCAM</a> is the building block of Foster’s methodology, which stands for <code class="docutils literal notranslate"><span class="pre">Partitioning</span></code>, <code class="docutils literal notranslate"><span class="pre">Communication</span></code>, <code class="docutils literal notranslate"><span class="pre">Agglomeration</span></code>, and <code class="docutils literal notranslate"><span class="pre">Mapping</span></code>. Since the design and paradigm of parallel programming is a broad topic and beyond the scope of this tutorial, we will primarily focus on the Communication part of PCAM in this tutorial, and we shall see:</p>
<ul class="simple">
<li><p>What is a communication pattern in parallel computing</p></li>
<li><p>A brief overview of Map and Gather communication patterns</p></li>
<li><p>What are Stencil operation and its importance in numerical analysis</p></li>
<li><p>Solving 2D heat equation using Stencil communication pattern in CUDA</p></li>
<li><p>CUDA thread hierarchy</p></li>
<li><p>Profiling our 2D heat equation code example</p></li>
<li><p>How to Optimize our code example</p></li>
<li><p>How to Debug our code example</p></li>
</ul>
</section>
<section id="communication-patterns">
<h1>Communication Patterns<a class="headerlink" href="#communication-patterns" title="Link to this heading"></a></h1>
<p>What we know so far is that a parallel computation is divided into tasks, where each task is a unit of work. In CUDA, these tasks can be represented by CUDA threads. These threads need to work together and require inter-thread communication. In CUDA, communication happens through memory. For example, threads may need to read from an input memory location and write to the same memory location. Sometimes these threads exchange partial results with each other to compute the global result.</p>
<p>The communication between threads depends on the nature of the problem we wish to solve; For example, suppose the salary of ‘n’ employees in a company is stored in an array. Let us call this array ‘salary-array’. Now, we want to add a gift amount of 100 NOK to each employee’s salary. This task can be solved serially by iterating through the array, from the first to the last element in the array, and adding 100 NOK to each employee; clearly, this task will take ‘n’ steps to finish. The same task could have been solved parallelly in a constant time through the ‘MAP’ operation. <a class="reference internal" href="#fig-map"><span class="std std-ref">MAP</span></a> is a communication pattern where each thread reads and writes to a specific memory location, or we can say that there is a one-to-one correspondence between input and output. GPUs are very efficient in solving such problems, but Map is not very flexible in solving all types of computation problems; for example, Map cannot compute and store the average of 3 subsequent salaries of the employees in the array. However, another pattern called <a class="reference internal" href="#fig-gather"><span class="std std-ref">GATHER</span></a> could solve the problem efficiently. In the case of <code class="docutils literal notranslate"><span class="pre">Gather</span></code> operation, each thread would read the values from 3 different locations in the memory and write them into a single place in the memory, as depicted in the <a class="reference internal" href="#fig-gather"><span class="std std-ref">figure</span></a>.</p>
<figure class="align-center" id="id2">
<span id="fig-map"></span><a class="reference internal image-reference" href="../../_images/MAP.svg"><img alt="../../_images/MAP.svg" src="../../_images/MAP.svg" style="width: 500px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 1: MAP</span><a class="headerlink" href="#id2" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id3">
<span id="fig-gather"></span><a class="reference internal image-reference" href="../../_images/Gather.svg"><img alt="../../_images/Gather.svg" src="../../_images/Gather.svg" style="width: 500px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 2: GATHER</span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>So far, we have seen that there are predefined communication patterns that appear now and again to solve a bigger problem, these patterns describe the basic solution to a problem and can be combined to solve a complex computational problem efficiently.</p>
</section>
<section id="id1">
<h1>Stencil<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<p>Stencil operation computes the value of a single element by applying a function to a collection of neighboring elements.
A very simple 9 elements stencil operation is shown in <a class="reference internal" href="#fig-coordsys-rect"><span class="std std-ref">Fig 1</span></a>. In one dimension, a nine-point stencil around a point at position <span class="math notranslate nohighlight">\(x\)</span> would apply some function to the values at these positions:</p>
<div class="math notranslate nohighlight">
\[   {x − 4h, x − 3h, x − 2h, x − h, x, x + h, x + 2h, x + 3h, x + 4h}\]</div>
<figure class="align-center" id="id4">
<span id="fig-coordsys-rect"></span><a class="reference internal image-reference" href="../../_images/stencil.svg"><img alt="../../_images/stencil.svg" src="../../_images/stencil.svg" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 3: Nine elements stencil.</span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>As it can be seen from <a class="reference internal" href="#fig-coordsys-rect"><span class="std std-ref">Fig 3</span></a> that 9 inputs are used to produce a single output. And if you look at our 9-point stencil operation again, then you will find that it is the <a class="reference external" href="https://en.wikipedia.org/wiki/Finite_difference_method">finite-difference-method(FDM)</a> of order 8 to calculate the first derivative of a function <span class="math notranslate nohighlight">\({\displaystyle f(x)}\)</span> at a point <span class="math notranslate nohighlight">\(x\)</span>, and that is the reason why Stencil operation is at the core of many algorithms that solve partial differential equations.</p>
</section>
<section id="d-heat-equation">
<h1>2D Heat Equation<a class="headerlink" href="#d-heat-equation" title="Link to this heading"></a></h1>
<p>Heat dissipates into its surrounding by conduction, convection, and radiation. The process of transferring heat from the hotter part to the colder part of a material/body is called conduction. The heat equation models the flow of heat from the hotter part to the colder part of a body.</p>
<p>The heat equation is a fundamental differential equation because it is the building block for other differential equations and has applications across the sciences. <a class="reference internal" href="#eq-heat"><span class="std std-ref">Equation 1</span></a> is called the ideal heat equation because it models the heat flow in an ideal condition. For example, it does not consider the shape and type of the body. To apply it to real-world engineering problems, one should consider other physical constraints too.</p>
<div class="math notranslate nohighlight" id="eq-heat">
<span id="equation-eq-heat"></span><span class="eqno">(1)<a class="headerlink" href="#eq-heat" title="Link to this equation"></a></span>\[\begin{array}{cc}\frac{\delta u}{\delta t} =
\alpha \left (\frac{\delta^2 u}{\delta y^2} +
\frac{\delta^2 u}{\delta x^2}
\right)
\end{array}\]</div>
<p>If we try to solve <a class="reference internal" href="#eq-heat"><span class="std std-ref">Equation 1</span></a>. We get:</p>
<div class="math notranslate nohighlight" id="eq-heat-sol">
<span id="equation-eq-heat-sol"></span><span class="eqno">(2)<a class="headerlink" href="#eq-heat-sol" title="Link to this equation"></a></span>\[\begin{array}{cc}
u_{ij}^{t+1} = u_{ij}^{t} + \Delta t\times\alpha
\left(
\frac{u_{i+1}^{t} + u_{i-1}^{t} + u_{j+1}^{t} +u_{j-1}^{t} -4u_{ij}^{t}}{h^2}
\right)
\end{array}\]</div>
<p>From <a class="reference internal" href="#eq-heat-sol"><span class="std std-ref">Equation 2</span></a>, we can see that the change in temperature after time <span class="math notranslate nohighlight">\(\Delta t\)</span> at a particular cell <span class="math notranslate nohighlight">\(u_{ij}\)</span> on the 2D surface, depends on its non-diagonal neighboring cells, as shown in <a class="reference internal" href="#fig-grid-discrete"><span class="std std-ref">Fig 4</span></a>. You can also notice from <a class="reference internal" href="#fig-grid-discrete"><span class="std std-ref">Fig 4</span></a> that it is a 5-point stencil operation.</p>
<figure class="align-center" id="id5">
<span id="fig-grid-discrete"></span><a class="reference internal image-reference" href="../../_images/grid.svg"><img alt="../../_images/grid.svg" src="../../_images/grid.svg" style="width: 200px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 4: Discrete grid visualization.</span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Now, it is easy to translate <a class="reference internal" href="#eq-heat-sol"><span class="std std-ref">Equation 2</span></a> into pseudocode.</p>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-text">Pseudocode for the heat flow on a 2D grid</span><a class="headerlink" href="#id6" title="Link to this code"></a></div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for time 1 -&gt; n :
    for cell(1,1) -&gt; cel(grid_size, grid_size) :
         Temp_Next(i,j) = Temp_Cur(i,j) +
                          (
                           Temp_Cur(i+1,j) + Temp_Cur(i-1,j) +
                           Temp_Cur(i,j+1) + Temp_Cur(i,j-1) -
                           4.0 * Temp_Cur(i,j)
                          ) / Cell_Surface_Area
</pre></div>
</div>
</div>
<section id="neumann-boundary-condition">
<span id="sec-nbc"></span><h2>Neumann Boundary Condition<a class="headerlink" href="#neumann-boundary-condition" title="Link to this heading"></a></h2>
</section>
<p>As we can see from <a class="reference internal" href="#fig-grid-discrete"><span class="std std-ref">Fig 4</span></a> that each cell needs 4 neighbor cells to calculate ‘Temp_Next’. But, what will happen at the corners and the edges of our grid? We will fall short of 2 cells at each corner-cell, and 1 cell at each edge-cell. To fix this problem, we will use <code class="docutils literal notranslate"><span class="pre">Neumann</span> <span class="pre">Boundary</span> <span class="pre">Conditions</span></code> which say that the temperature change is <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(\left( \frac{\delta u}{\delta t} = 0 \right )\)</span> at the boundary. To satisfy the boundary condition, we create a Halo around our grid and copy the temperature from the adjacent edge-cell to the adjacent halo-cell, as shown in <a class="reference internal" href="#fig-halo"><span class="std std-ref">Fig 6</span></a>.</p>
<figure class="align-center" id="id7">
<span id="fig-halo"></span><a class="reference internal image-reference" href="../../_images/halo.svg"><img alt="../../_images/halo.svg" src="../../_images/halo.svg" style="width: 200px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 5: Halo around the grid.</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Now, we have everything in place to draw a <a class="reference internal" href="#fig-flowchart"><span class="std std-ref">flow chart</span></a> for the heat simulation in 2D.</p>
<figure class="align-center" id="id8">
<span id="fig-flowchart"></span><a class="reference internal image-reference" href="../../_images/flowchart.svg"><img alt="../../_images/flowchart.svg" src="../../_images/flowchart.svg" style="width: 300px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 6: 2D heat simulation.</span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
<section id="a-sequential-version-of-2d-heat-simulation">
<span id="sec-2dheq-serial"></span><h2>A sequential version of 2D heat simulation<a class="headerlink" href="#a-sequential-version-of-2d-heat-simulation" title="Link to this heading"></a></h2>
</section>
<p>Here is how the 2D heat equation is implemented in C, and the highlighted lines show the main stencil operation. The complete code can be downloaded from the <a class="reference internal" href="#sec-2dheq-resources"><span class="std std-ref">Resources</span></a> section.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// Evolve the &#39;next&#39; field from &#39;curr&#39; with total grid size of (size + 2)^2,</span>
<span class="linenos"> 2</span><span class="c1">// &#39;alpha&#39; is the diffusion constant and &#39;dt&#39; is the time derivative</span>
<span class="linenos"> 3</span><span class="kt">void</span><span class="w"> </span><span class="nf">evolve</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span>
<span class="linenos"> 4</span><span class="w">	    </span><span class="n">cell_size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 5</span><span class="cp">#define CURR(i,j) curr[((i)+1)*(size+2)+(j)+1]</span>
<span class="linenos"> 6</span><span class="cp">#define NEXT(i,j) next[((i)+1)*(size+2)+(j)+1]</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alpha</span><span class="o">*</span><span class="n">dt</span><span class="p">;</span>
<span class="hll"><span class="linenos"> 8</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
</span><span class="hll"><span class="linenos"> 9</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
</span><span class="hll"><span class="linenos">10</span><span class="w">      </span><span class="n">NEXT</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span>
</span><span class="hll"><span class="linenos">11</span><span class="w">				   </span><span class="p">(</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="o">+</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="mf">-4.0</span><span class="o">*</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">cell_size</span><span class="o">*</span><span class="n">cell_size</span><span class="p">)</span>
</span><span class="hll"><span class="linenos">12</span><span class="w">				   </span><span class="p">);</span><span class="w"> </span>
</span><span class="hll"><span class="linenos">13</span><span class="p">}</span>
</span></pre></div>
</div>
<section id="compilation-and-execution-on-betzy">
<span id="sec-2dheq-execution"></span><h2>Compilation and execution on Betzy<a class="headerlink" href="#compilation-and-execution-on-betzy" title="Link to this heading"></a></h2>
</section>
<p>Follow these steps to compile and run the <a class="reference internal" href="#sec-2dheq-resources"><span class="std std-ref">2DHeatEquation</span></a> project on Betzy.</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#sec-2dheq-resources"><span class="std std-ref">Download</span></a> tarball to your local client.</p></li>
<li><p><a class="reference internal" href="#sec-copy"><span class="std std-ref">Upload</span></a> it to your Betzy login</p></li>
<li><p><a class="reference internal" href="#sec-uncompress"><span class="std std-ref">Uncompress</span></a> it</p></li>
<li><p><a class="reference internal" href="#sec-build"><span class="std std-ref">Build</span></a> it</p></li>
<li><p><a class="reference internal" href="#sec-execute"><span class="std std-ref">Execute</span></a> it</p></li>
</ol>
<p>The output of our serial version of code should look something similar to this.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>srun:<span class="w"> </span>job<span class="w"> </span><span class="m">371234</span><span class="w"> </span>queued<span class="w"> </span>and<span class="w"> </span>waiting<span class="w"> </span><span class="k">for</span><span class="w"> </span>resources
srun:<span class="w"> </span>job<span class="w"> </span><span class="m">371234</span><span class="w"> </span>has<span class="w"> </span>been<span class="w"> </span>allocated<span class="w"> </span>resources
Solving<span class="w"> </span>heat<span class="w"> </span>equation<span class="w"> </span><span class="k">for</span><span class="w"> </span>grid<span class="w"> </span><span class="m">500</span><span class="w"> </span>x<span class="w"> </span><span class="m">500</span><span class="w"> </span>with<span class="w"> </span><span class="m">1000</span><span class="w"> </span>iterations
Used<span class="w"> </span><span class="m">0</span>.509<span class="w"> </span>seconds<span class="w"> </span>to<span class="w"> </span>evolve<span class="w"> </span>field
Average<span class="w"> </span><span class="nb">time</span><span class="w"> </span>per<span class="w"> </span>field<span class="w"> </span>update:<span class="w"> </span><span class="m">0</span>.509<span class="w"> </span>ms
</pre></div>
</div>
<p>It is also possible to <a class="reference internal" href="#fig-2dheateq"><span class="std std-ref">visualize</span></a> the output, as shown below.</p>
<figure class="align-center" id="id9">
<span id="fig-2dheateq"></span><a class="reference internal image-reference" href="../../_images/anim_out.gif"><img alt="../../_images/anim_out.gif" src="../../_images/anim_out.gif" style="width: 250px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 7: Heat diffusion in 2-dimension (Animation).</span><a class="headerlink" href="#id9" title="Link to this image"></a></p>
</figcaption>
</figure>
<section id="cuda-version-of-2d-heat-simulation">
<span id="sec-2dheq-cuda"></span><h2>CUDA version of 2D heat simulation<a class="headerlink" href="#cuda-version-of-2d-heat-simulation" title="Link to this heading"></a></h2>
</section>
<p>Here is how the 2D heat equation is implemented in CUDA, and the highlighted lines show the main stencil operation. The complete code can be downloaded from the <a class="reference internal" href="#sec-2dheq-resources"><span class="std std-ref">Resources</span></a> section.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// Evolve the &#39;next&#39; field from &#39;curr&#39; with total grid size of (size + 2)^2,                                          </span>
<span class="linenos"> 2</span><span class="c1">// &#39;alpha&#39; is the diffusion constant and &#39;dt&#39; is the time derivative                                                  </span>
<span class="linenos"> 3</span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">evolve</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span>
<span class="linenos"> 4</span><span class="w">                       </span><span class="n">cell_size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 5</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="linenos"> 6</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="cp">#define CURR(i,j) curr[((i)+1)*(size+2)+(j)+1]</span>
<span class="linenos"> 8</span><span class="cp">#define NEXT(i,j) next[((i)+1)*(size+2)+(j)+1]</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="c1">// Additional variables                                                                                             </span>
<span class="linenos">10</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cell_size</span><span class="p">;</span>
<span class="linenos">11</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span><span class="w">                                                                                                </span>
<span class="linenos">12</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="hll"><span class="linenos">13</span><span class="w">    </span><span class="n">NEXT</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span>
</span><span class="hll"><span class="linenos">14</span><span class="w">                                 </span><span class="p">(</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span>
</span><span class="hll"><span class="linenos">15</span><span class="w">                                  </span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="o">+</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span>
</span><span class="hll"><span class="linenos">16</span><span class="w">                                  </span><span class="mf">4.0</span><span class="o">*</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">cell_size</span><span class="o">*</span><span class="n">cell_size</span><span class="p">)</span>
</span><span class="hll"><span class="linenos">17</span><span class="w">                                 </span><span class="p">);</span>
</span><span class="linenos">18</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">19</span><span class="p">}</span>
</pre></div>
</div>
<p>Follow the instructions to <a class="reference internal" href="#sec-build"><span class="std std-ref">Build</span></a> and <a class="reference internal" href="#sec-execute"><span class="std std-ref">Run</span></a> the CUDA code on Betzy.</p>
<p>The output of our CUDA code should look something similar to this.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Solving</span> <span class="n">heat</span> <span class="n">equation</span> <span class="k">for</span> <span class="n">grid</span> <span class="mi">500</span> <span class="n">x</span> <span class="mi">500</span> <span class="k">with</span> <span class="mi">1000</span> <span class="n">iterations</span>
<span class="n">Launching</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="n">grids</span> <span class="k">with</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="n">blocks</span>
<span class="n">Used</span> <span class="mf">0.017</span> <span class="n">seconds</span> <span class="n">to</span> <span class="n">evolve</span> <span class="n">field</span>
<span class="n">Average</span> <span class="n">time</span> <span class="n">per</span> <span class="n">field</span> <span class="n">update</span><span class="p">:</span> <span class="mf">0.017</span> <span class="n">ms</span>

</pre></div>
</div>
<p>The code explanation is straightforward and very similar to the serial version. However, few new concepts have been introduced here, like <code class="docutils literal notranslate"><span class="pre">Grid</span></code>, <code class="docutils literal notranslate"><span class="pre">Blocks</span></code>, and <code class="docutils literal notranslate"><span class="pre">Threads</span></code>. We try to explain each of them briefly; however, an in-depth explanation is given on the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#thread-hierarchy">Nvidia CUDA documentation page</a>.</p>
<section id="cuda-thread-hierarchy">
<span id="sec-cudathreadhierarchy"></span><h2>CUDA thread hierarchy<a class="headerlink" href="#cuda-thread-hierarchy" title="Link to this heading"></a></h2>
</section>
<p>In a typical CUDA program, first, the CPU allocates storage on the GPU and copies the input data from the CPU to the GPU. The function which runs on a GPU is called a <code class="docutils literal notranslate"><span class="pre">Kernel</span></code> function or simply a Kernel. The CPU launches the Kernel, and the execution transfers from the CPU to the GPU. Input data get processed on the GPU and the results transfer back to the CPU.</p>
<p>During the execution of the Kernel, CUDA launches a large number of threads. To organize these threads, CUDA maintains a thread hierarchy. According to this 2-tier thread hierarchy, threads are divided into <code class="docutils literal notranslate"><span class="pre">Blocks</span></code> of threads, and blocks are divided into <code class="docutils literal notranslate"><span class="pre">Grids</span></code> of blocks, as shown in <a class="reference internal" href="#fig-grid-n-blocks"><span class="std std-ref">figure 8</span></a>.</p>
<figure class="align-center" id="id10">
<span id="fig-grid-n-blocks"></span><a class="reference internal image-reference" href="../../_images/grid_block.svg"><img alt="../../_images/grid_block.svg" src="../../_images/grid_block.svg" style="width: 500px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 8: CUDA Grid, Blocks, and Threads.</span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>A user has full control over organizing the threads into blocks and grids, and this can be done during the Kernel call; on the host side. An example of this is shown below.</p>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-text">Example of thread organization in Blocks and Grids.</span><a class="headerlink" href="#id11" title="Link to this code"></a></div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> const dim3 blockSize(32,32);
 const dim3 gridSize(24,19);

 my_kernel&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;()
</pre></div>
</div>
</div>
<p>The above example shows that my_kernel will spawn 466,944 threads in total. To organize these many threads, the threads are organized into blocks of 32x32 threads in X and Y dimensions. So, each block has 32 threads in the X dimension, and 32 threads in the Y dimension; in total, each block has 1024 threads. Now the blocks are arranged in a grid of 24 blocks in the X dimension, and 19 blocks in the Y dimension; in total, 456 blocks in a grid.</p>
<p>Please note that dim3 is a derived data type wrapped around the intrinsic integer data type. It has three unsigned integers to store X, Y, and Z dimensions respectively.</p>
<p>The main purpose of this 2-tier hierarchy is to uniquely identify a thread in a pool of threads. Since thread blocks are spread across a 2-dimensional grid, it is easy to identify the block number, at run time, using variables supplied by CUDA-Runtime. Let us try to understand this with an example. Suppose, at a particular moment in time, we want to know the offset of our thread, then what should be our approach to find the global index of our thread?</p>
<div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-text">Uniquely identify a thread within a pool of threads launched by a Kernel.</span><a class="headerlink" href="#id12" title="Link to this code"></a></div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> /*
 CUDA-Runtime can provide these variables at runtime:
 ----------------------------------------------------
 1. gridDim.x
 2. gridDim.y
 3. blockIdx.x
 4. blockIdx.y
 5. threadIdx.x
 6. threadIdx.y
 */

 // Calculate the global thread index using these steps:

 // 1. Find the block number in which the current thread resides
 int global_block_index = gridDim.x*blockIdx.y + blockIdx.x;

 // If 1 block contains m*n threads then p blocks contain how many threads? p*m*n
 int total_threads = gloabal_block_index * blockDim.x*blockDim.y;

 // 3. Find the index of the current thread within the current block
 int local_thread_index = threadIdx.y*blockDim.x + threadIdx.x;

 // 4. Global thread index
 int global_thread_index =  total_threads + local_thread_index

 // One liner
 int offset = (gridDim.x*blockIdx.y + blockIdx.x)*(blockDim.x*blockDim.y)
              + threadIdx.y*blockDim.x + threadIdx.x;

 // Calculate global row and column of a thread
 int row = blockIdx.x * blockDim.x + threadIdx.x;
 int col = blockIdx.y * blockDim.y + threadIdx.y;
</pre></div>
</div>
</div>
<section id="designing-the-cuda-code">
<span id="sec-codedesign"></span><h2>Designing the Cuda code<a class="headerlink" href="#designing-the-cuda-code" title="Link to this heading"></a></h2>
</section>
<p>In this section, we will try to explain the sample Cuda code with the knowledge we got in the previous <a class="reference internal" href="#sec-cudathreadhierarchy"><span class="std std-ref">section</span></a>.</p>
<p>In our Cuda code example, we used the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#um-unified-memory-programming-hd">Unified Memory</a> feature of CUDA-6.0, and that is the reason why we did not allocate the memory using <code class="docutils literal notranslate"><span class="pre">cudaMalloc</span></code>, and also the data movement from host-to-device and device-to-host was not performed using <code class="docutils literal notranslate"><span class="pre">cudaMemcpy</span></code>; however, these two operations were taken care of by a unified function called <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged</span></code>. This function allocates a unified pool of memory which is accessible both from the host and the device. Let us try to figure out where these operations were performed in our Cuda code.</p>
<p>In the following lines of code, you may see that after including some libraries and header files, we declared a few variables in <code class="docutils literal notranslate"><span class="pre">line:77,78</span></code>, like <code class="docutils literal notranslate"><span class="pre">dim_block</span></code>, and <code class="docutils literal notranslate"><span class="pre">dim_grid</span></code>. Here <code class="docutils literal notranslate"><span class="pre">dim3</span></code> is a data type, provided by the CUDA-Runtime environment. The main use of this data type is to define the dimensions of a block and a grid. We kept the block size fixed with 256 threads in each block. The number of blocks in a grid is calculated in <code class="docutils literal notranslate"><span class="pre">line:84</span></code>. Please note that this number of blocks can only accommodate <code class="docutils literal notranslate"><span class="pre">grid+2</span></code> elements, but our 2D grid has <code class="docutils literal notranslate"><span class="pre">grid+2</span> <span class="pre">x</span> <span class="pre">grid+2</span></code> elements, and that is the reason why we specified <code class="docutils literal notranslate"><span class="pre">dim3(grids,</span> <span class="pre">grids)</span></code> in <code class="docutils literal notranslate"><span class="pre">line:85</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">18</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;png_writer.h&quot;</span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span>
<span class="linenos">21</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda_runtime_api.h&gt;</span>
<span class="linenos">22</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>
<span class="linenos">23</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span>
<span class="linenos">24</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="linenos">25</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="linenos">26</span>
<span class="linenos">27</span><span class="c1">// Default grid size (GRID_SIZE * GRID_SIZE elements are needed)</span>
<span class="linenos">28</span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">DEFAULT_GRID_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span>
<span class="linenos">29</span><span class="c1">// Default number of iterations if no command line argument is given</span>
<span class="linenos">30</span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">DEFAULT_ITER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>
<span class="linenos">31</span><span class="c1">// Default diffusion constant</span>
<span class="linenos">32</span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">DEFAULT_ALPHA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span>
<span class="linenos">33</span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">DEFAULT_CELL_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.01</span><span class="p">;</span>
<span class="linenos">34</span><span class="c1">// Number of blocks to use when launching CUDA kernels</span>
<span class="linenos">35</span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">FIXED_BLOCKS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="linenos">36</span>
<span class="linenos">37</span><span class="c1">// Forward declarations</span>
<span class="linenos">38</span><span class="c1">// Initialize the field with a size of (size + 2)^2</span>
<span class="linenos">39</span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">init_field</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">field</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="linenos">40</span><span class="c1">// Evolve the &#39;next&#39; field from &#39;curr&#39; with total grid size of (size + 2)^2,</span>
<span class="linenos">41</span><span class="c1">// &#39;alpha&#39; is the diffusion constant and &#39;dt&#39; is the time derivative</span>
<span class="linenos">42</span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">evolve</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">cell_size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">dt</span><span class="p">);</span>
<span class="linenos">43</span><span class="c1">// Helper method to save the field to PNG</span>
<span class="linenos">44</span><span class="kt">void</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">field</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">iteration</span><span class="p">);</span>
<span class="linenos">45</span><span class="c1">// Check the return value of a CUDA function and abort if abnormal behavior</span>
<span class="linenos">46</span><span class="kt">void</span><span class="w"> </span><span class="nf">check_cuda</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
<span class="linenos">47</span>
<span class="linenos">48</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">49</span><span class="w">  </span><span class="c1">// grid_size represents the N x N grid to compute over</span>
<span class="linenos">50</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">grid_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEFAULT_GRID_SIZE</span><span class="p">;</span>
<span class="linenos">51</span><span class="w">  </span><span class="c1">// The number of iterations to perform to solve the equation</span>
<span class="linenos">52</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">num_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEFAULT_ITER</span><span class="p">;</span>
<span class="linenos">53</span><span class="w">  </span><span class="c1">// Diffusion constant</span>
<span class="linenos">54</span><span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEFAULT_ALPHA</span><span class="p">;</span>
<span class="linenos">55</span><span class="w">  </span><span class="c1">// Size of each grid cell</span>
<span class="linenos">56</span><span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">cell_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEFAULT_CELL_SIZE</span><span class="p">;</span>
<span class="linenos">57</span><span class="w">  </span><span class="c1">// Calculate the time increment to propagate with</span>
<span class="linenos">58</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cell_size</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">cell_size</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cell_size</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)));</span>
<span class="linenos">59</span><span class="w">  </span><span class="c1">// Save interval</span>
<span class="linenos">60</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">save_interval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="linenos">61</span>
<span class="linenos">62</span><span class="w">  </span><span class="c1">// Command line handling</span>
<span class="linenos">63</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">64</span><span class="w">    </span><span class="n">grid_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="linenos">65</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">66</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">67</span><span class="w">    </span><span class="n">num_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="linenos">68</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">69</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">70</span><span class="w">    </span><span class="n">save_interval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="linenos">71</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">72</span>
<span class="linenos">73</span><span class="w">  </span><span class="c1">// Initialization</span>
<span class="linenos">74</span><span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Solving heat equation for grid </span><span class="se">\033</span><span class="s">[0;35m%d x %d</span><span class="se">\033</span><span class="s">[0m with </span><span class="se">\033</span><span class="s">[0;35m%d</span><span class="se">\033</span><span class="s">[0m iterations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="linenos">75</span><span class="w">    </span><span class="n">grid_size</span><span class="p">,</span><span class="w"> </span><span class="n">grid_size</span><span class="p">,</span><span class="w"> </span><span class="n">num_iter</span><span class="p">);</span>
<span class="linenos">76</span><span class="w">  </span><span class="c1">// Setup CUDA block and grid dimensions to use for kernel launch</span>
<span class="hll"><span class="linenos">77</span><span class="w">  </span><span class="n">dim3</span><span class="w"> </span><span class="n">dim_block</span><span class="p">;</span>
</span><span class="hll"><span class="linenos">78</span><span class="w">  </span><span class="n">dim3</span><span class="w"> </span><span class="n">dim_grid</span><span class="p">;</span>
</span><span class="linenos">79</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">80</span><span class="w">    </span><span class="n">dim_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dim3</span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">grid_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="linenos">81</span><span class="w">    </span><span class="n">dim_grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dim3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="linenos">82</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">83</span><span class="w">    </span><span class="n">dim_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dim3</span><span class="p">(</span><span class="n">FIXED_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">FIXED_BLOCKS</span><span class="p">);</span>
<span class="hll"><span class="linenos">84</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">grids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FIXED_BLOCKS</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">FIXED_BLOCKS</span><span class="p">;</span>
</span><span class="hll"><span class="linenos">85</span><span class="w">    </span><span class="n">dim_grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dim3</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span><span class="w"> </span><span class="n">grids</span><span class="p">);</span>
</span><span class="linenos">86</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">87</span><span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Launching </span><span class="se">\033</span><span class="s">[0;35m(%d, %d)</span><span class="se">\033</span><span class="s">[0m grids with </span><span class="se">\033</span><span class="s">[0;35m(%d, %d)</span><span class="se">\033</span><span class="s">[0m blocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">lines:90,91</span></code> we declared two pointers to deference the memory location, however, at this point in time no memory was allocated and therefore they are only null-pointers. <code class="docutils literal notranslate"><span class="pre">lines:92,94</span></code> used the <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged</span></code> function to allocate the unified memory space and map it to the pointers, which were declared in <code class="docutils literal notranslate"><span class="pre">lines:90,91</span></code>. Henceforth, all the modifications, in the allocated memory space, will be carried out using these pointers. In <code class="docutils literal notranslate"><span class="pre">line:97</span></code> a device Kernel was launched which would calculate the initial and boundary conditions of the grid.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 88</span><span class="w">    </span><span class="n">dim_grid</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">dim_grid</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">dim_block</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">dim_block</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="linenos"> 89</span><span class="w">  </span><span class="c1">// Setup grid arrays</span>
<span class="hll"><span class="linenos"> 90</span><span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">grid</span><span class="p">;</span>
</span><span class="hll"><span class="linenos"> 91</span><span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">next_grid</span><span class="p">;</span>
</span><span class="hll"><span class="linenos"> 92</span><span class="w">  </span><span class="n">check_cuda</span><span class="p">(</span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)),</span>
</span><span class="hll"><span class="linenos"> 93</span><span class="w">    </span><span class="s">&quot;Could not allocate &#39;grid&#39;&quot;</span><span class="p">);</span>
</span><span class="hll"><span class="linenos"> 94</span><span class="w">  </span><span class="n">check_cuda</span><span class="p">(</span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_grid</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)),</span>
</span><span class="hll"><span class="linenos"> 95</span><span class="w">    </span><span class="s">&quot;Could not allocate &#39;next_grid&#39;&quot;</span><span class="p">);</span>
</span><span class="linenos"> 96</span><span class="w">  </span>
<span class="hll"><span class="linenos"> 97</span><span class="w">  </span><span class="n">init_field</span><span class="o">&lt;&lt;&lt;</span><span class="n">dim_grid</span><span class="p">,</span><span class="w"> </span><span class="n">dim_block</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">grid_size</span><span class="p">);</span>
</span><span class="linenos"> 98</span><span class="w">  </span><span class="n">check_cuda</span><span class="p">(</span><span class="n">cudaGetLastError</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;&#39;init_field&#39; of &#39;grid&#39; failed&quot;</span><span class="p">);</span>
<span class="linenos"> 99</span><span class="w">  </span><span class="n">init_field</span><span class="o">&lt;&lt;&lt;</span><span class="n">dim_grid</span><span class="p">,</span><span class="w"> </span><span class="n">dim_block</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">next_grid</span><span class="p">,</span><span class="w"> </span><span class="n">grid_size</span><span class="p">);</span>
<span class="linenos">100</span><span class="w">  </span><span class="n">check_cuda</span><span class="p">(</span><span class="n">cudaGetLastError</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;&#39;init_field&#39; of &#39;next_grid&#39; failed&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The main stencil operation was performed in the <code class="docutils literal notranslate"><span class="pre">evolve</span></code> device kernel, which was run for the required number of iterations and timed using a time function. The logic behind the evolve function is similar to the serial version of the code, but in the Cuda version, <code class="docutils literal notranslate"><span class="pre">evolve</span></code> function is performed parallelly by Cuda threads. In <code class="docutils literal notranslate"><span class="pre">line:122</span></code>, system-level synchronization is used to make sure that the GPU and the CPU are synced; before any computed result is made available on the CPU. And lastly, the allocated memory is freed up in <code class="docutils literal notranslate"><span class="pre">line:138,139</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">102</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">save_interval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">103</span><span class="w">    </span><span class="n">check_cuda</span><span class="p">(</span><span class="n">cudaDeviceSynchronize</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;&#39;init_field&#39; of &#39;grid&#39; or &#39;next_grid&#39; failed&quot;</span><span class="p">);</span>
<span class="linenos">104</span><span class="w">    </span><span class="n">save</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">grid_size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="linenos">105</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">34</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">106</span><span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grid_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">107</span><span class="w">	</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grid_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">108</span><span class="w">	  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">grid_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="linenos">109</span><span class="w">	  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %2.0f&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">grid</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="linenos">110</span><span class="w">	</span><span class="p">}</span>
<span class="linenos">111</span><span class="w">	</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="linenos">112</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">113</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">114</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">115</span>
<span class="linenos">116</span><span class="w">  </span><span class="c1">// Main calculation</span>
<span class="linenos">117</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">start_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="p">();</span>
<span class="linenos">118</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">num_iter</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">119</span><span class="w">    </span><span class="c1">// One iteration of the heat equation</span>
<span class="hll"><span class="linenos">120</span><span class="w">    </span><span class="n">evolve</span><span class="o">&lt;&lt;&lt;</span><span class="n">dim_grid</span><span class="p">,</span><span class="w"> </span><span class="n">dim_block</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">next_grid</span><span class="p">,</span><span class="w"> </span><span class="n">grid_size</span><span class="p">,</span><span class="w"> </span><span class="n">cell_size</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">);</span>
</span><span class="linenos">121</span><span class="w">    </span><span class="c1">// Wait until the kernel is done running before performing pointer swap</span>
<span class="hll"><span class="linenos">122</span><span class="w">    </span><span class="n">check_cuda</span><span class="p">(</span><span class="n">cudaDeviceSynchronize</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Waiting for evolve before pointer swap&quot;</span><span class="p">);</span>
</span><span class="linenos">123</span><span class="w">    </span><span class="c1">// Exchange old grid with the new updated grid</span>
<span class="linenos">124</span><span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grid</span><span class="p">;</span>
<span class="linenos">125</span><span class="w">    </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_grid</span><span class="p">;</span>
<span class="linenos">126</span><span class="w">    </span><span class="n">next_grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="linenos">127</span>
<span class="linenos">128</span><span class="w">    </span><span class="c1">// Save image if necessary</span>
<span class="linenos">129</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">save_interval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">save_interval</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">130</span><span class="w">      </span><span class="n">save</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">grid_size</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="linenos">131</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">132</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">133</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">total_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">;</span>
<span class="linenos">134</span><span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Used </span><span class="se">\033</span><span class="s">[0;35m%.3f</span><span class="se">\033</span><span class="s">[0m seconds to evolve field</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">total_time</span><span class="p">);</span>
<span class="linenos">135</span><span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Average time per field update: </span><span class="se">\033</span><span class="s">[0;35m%.3f</span><span class="se">\033</span><span class="s">[0m ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">total_time</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1e3</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">num_iter</span><span class="p">);</span>
<span class="linenos">136</span>
<span class="linenos">137</span><span class="w">  </span><span class="c1">// Free data and terminate</span>
<span class="hll"><span class="linenos">138</span><span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
</span><span class="hll"><span class="linenos">139</span><span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">next_grid</span><span class="p">);</span>
</span><span class="linenos">140</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</pre></div>
</div>
<section id="profiling">
<span id="sec-2dheq-profiling"></span><h2>Profiling<a class="headerlink" href="#profiling" title="Link to this heading"></a></h2>
</section>
<p>We will check our kernel performances using Nvidia Nsight Systems, which is a profiler and can be downloaded from Nvidia`s <a class="reference external" href="https://developer.nvidia.com/nsight-systems">official website</a>.</p>
<p>Profiling your Cuda code on <code class="docutils literal notranslate"><span class="pre">Betzy</span></code> or <code class="docutils literal notranslate"><span class="pre">Saga</span></code> is not difficult, but involves a few steps to follow.
We will use <code class="docutils literal notranslate"><span class="pre">nsys</span></code> CLI to generate a view of our Cuda executable on the GPU cluster, and later analyze it on our local computer.</p>
<p>The basic <code class="docutils literal notranslate"><span class="pre">qdrep</span></code> file can be generated by following the command.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>@login-2.BETZY<span class="w"> </span>~<span class="o">]</span>$<span class="w"> </span>module<span class="w"> </span>load<span class="w"> </span>CUDA/11.4.1
<span class="o">[</span>@login-2.BETZY<span class="w"> </span>~<span class="o">]</span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>HeatEq2D_Stencil/<span class="w"> </span>
<span class="o">[</span>@login-2.BETZY<span class="w"> </span>~<span class="o">]</span>$<span class="w"> </span>make<span class="w"> </span>clean
<span class="o">[</span>@login-2.BETZY<span class="w"> </span>~<span class="o">]</span>$<span class="w"> </span>make<span class="w"> </span>all
<span class="o">[</span>@login-2.BETZY<span class="w"> </span>~<span class="o">]</span>$<span class="w"> </span>srun<span class="w"> </span>--account<span class="o">=[</span>USR-ACC<span class="o">]</span><span class="w"> </span>--time<span class="o">=</span><span class="m">05</span>:00<span class="w"> </span>--partition<span class="o">=</span>accel<span class="w"> </span>--gpus<span class="o">=</span><span class="m">1</span><span class="w"> </span>--mem-per-cpu<span class="o">=</span>512M<span class="w"> </span>--job-name<span class="o">=</span>nsys_stencil<span class="w"> </span>nsys<span class="w"> </span>profile<span class="w"> </span>-t<span class="w"> </span>cuda<span class="w"> </span>-f<span class="w"> </span><span class="nb">true</span><span class="w"> </span>-o<span class="w"> </span>cuda<span class="w"> </span>./cuda
</pre></div>
</div>
<p>Detailed information about different nsys flags and options is provided <a class="reference external" href="https://docs.nvidia.com/nsight-systems/UserGuide/index.html">here</a>. But we use <code class="docutils literal notranslate"><span class="pre">-t</span></code> to profile <code class="docutils literal notranslate"><span class="pre">cuda</span></code> code, other options could be: openmp, mpi, openacc, nvtx, et cetera. Also, we used <code class="docutils literal notranslate"><span class="pre">-f</span> <span class="pre">true</span></code> to overwrite previously generated output, and <code class="docutils literal notranslate"><span class="pre">-o</span></code> to generate output in the folder ‘nvprofiler’ with the name ‘cuda’. Finally, we provided the executable name of our Cuda code. After executing the above command, we got output in the form of <code class="docutils literal notranslate"><span class="pre">cuda.qdrep</span></code>.</p>
<p>Now, download the ‘cuda.qdrep’ file to your local system using <code class="docutils literal notranslate"><span class="pre">scp</span></code> command, like this:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Run this command on your local computer, and replace username with your user id and &lt;absolute_path_to_the_file&gt; with the path to the file on the cluster. <code class="docutils literal notranslate"><span class="pre">pwd</span></code> or <code class="docutils literal notranslate"><span class="pre">readlink</span> <span class="pre">-f</span> <span class="pre">filename</span></code> would help to know the absolute path of the file.</p>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>scp<span class="w"> </span>-r<span class="w"> </span>username@betzy.sigma2.no:&lt;absolute_path_to_the_file&gt;<span class="w"> </span>.
</pre></div>
</div>
<p>Now, launch the Nvidia Nsight Systems (I assume it has already been <a class="reference external" href="https://developer.nvidia.com/nsight-systems">downloaded</a> and installed on your local system). This should open a window similar to <a class="reference internal" href="#fig-open-nnsys"><span class="std std-ref">figure 9</span></a>.</p>
<figure class="align-center" id="id13">
<span id="fig-open-nnsys"></span><a class="reference internal image-reference" href="../../_images/MainWindowNNS1.png"><img alt="../../_images/MainWindowNNS1.png" src="../../_images/MainWindowNNS1.png" style="width: 700px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 9: Nvidia Nsight Systems main window.</span><a class="headerlink" href="#id13" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>From the main menu, click ‘File’ and browse to the downloaded ‘cuda.qdrep’ file. This should open a ‘view’ similar to <a class="reference internal" href="#fig-main-view"><span class="std std-ref">figure 10</span></a>.</p>
<figure class="align-center" id="id14">
<span id="fig-main-view"></span><a class="reference internal image-reference" href="../../_images/NNSprojectexplorer2.png"><img alt="../../_images/NNSprojectexplorer2.png" src="../../_images/NNSprojectexplorer2.png" style="width: 700px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 10: Main view window.</span><a class="headerlink" href="#id14" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>From the dropdown menu, one can choose Timeline, Analysis, or Diagnostic Summary. We are interested in the Timeline view, but some important information, like Target summary, Thread summary, and GPU-CPU info can be found in the ‘Analysis’ tab of this menu. As we can see from <a class="reference internal" href="#fig-main-view"><span class="std std-ref">figure 10</span></a> that there are a few other collapsable tabs, like CPU(48), CUDA HW, etcetera. These tabs give information about the underlying resources our kernel used on the Target machine. If we click ‘CUDA HW’, then we see information about our kernels, as shown in <a class="reference internal" href="#fig-gpu-hw"><span class="std std-ref">figure 11</span></a>.</p>
<figure class="align-center" id="id15">
<span id="fig-gpu-hw"></span><a class="reference internal image-reference" href="../../_images/nnskernels_4.png"><img alt="../../_images/nnskernels_4.png" src="../../_images/nnskernels_4.png" style="width: 500px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 11: Executed kernels on the GPU.</span><a class="headerlink" href="#id15" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This information is quite handy in knowing that our ‘evolve’ kernel has consumed 97% of the total kernel execution time on the GPU; apparently because the kernel has been called 1000 times, and init_field kernel called only 2 times for initializing the current and the next grid.</p>
<p>Now, if we look to the right of this tab, then we see the actual timeline, as shown in <a class="reference internal" href="#fig-gpu-timeline"><span class="std std-ref">figure 12</span></a>.</p>
<figure class="align-center" id="id16">
<span id="fig-gpu-timeline"></span><a class="reference internal image-reference" href="../../_images/nnsslct_kernel_5.png"><img alt="../../_images/nnsslct_kernel_5.png" src="../../_images/nnsslct_kernel_5.png" style="width: 700px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 12: Actual timeline.</span><a class="headerlink" href="#id16" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Drag the mouse cursor over the timeline during ‘evolve’ kernel execution time and press <code class="docutils literal notranslate"><span class="pre">shift+z</span></code> simultaneously to zoom in the timeline, as shown in <a class="reference internal" href="#fig-zoom-in"><span class="std std-ref">figure 13</span></a>. The figure shows that the kernel starts executing at around .389528s and ends at .389550s and took 22,688 microseconds to finish. This is the time utilization of a single kernel call, but we have called it 1000 times.</p>
<figure class="align-center" id="id17">
<span id="fig-zoom-in"></span><a class="reference internal image-reference" href="../../_images/nnshoverzoom_6.png"><img alt="../../_images/nnshoverzoom_6.png" src="../../_images/nnshoverzoom_6.png" style="width: 700px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 13: Zoomed timeline.</span><a class="headerlink" href="#id17" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>To analyze the complete summary, we must go to the bottom left pane of the main window in Nsight System, and select <code class="docutils literal notranslate"><span class="pre">Stats</span> <span class="pre">System</span> <span class="pre">View</span></code> from the dropdown list. This should show the relevant summary of our kernel call, as shown in <a class="reference internal" href="#fig-cuda-summary"><span class="std std-ref">figure 14</span></a>. From the summary, we can see that most of the time was consumed by memory operations in moving data from host to device, and our ‘evolve’ kernel took around 22,516 microseconds on average.</p>
<figure class="align-center" id="id18">
<span id="fig-cuda-summary"></span><a class="reference internal image-reference" href="../../_images/nnscuda7.png"><img alt="../../_images/nnscuda7.png" src="../../_images/nnscuda7.png" style="width: 700px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 13: Summary of CUDA operations.</span><a class="headerlink" href="#id18" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>In the next section, we will try to reduce the total execution time by doing some memory optimization.</p>
<section id="optimization">
<span id="sec-2dheq-optimization"></span><h2>Optimization<a class="headerlink" href="#optimization" title="Link to this heading"></a></h2>
</section>
<p>In our Optimization section, we’ll try to incorporate onboard <code class="docutils literal notranslate"><span class="pre">constant</span></code> memory. Constant memory is only used for the reading purpose on the device and can be written or read from the host. The constant memory is accessible to all threads in a wrap, and each thread can access it uniformly.</p>
<p>Constant memory is located on the device and has its own on-chip cache, or we can say that each <a class="reference internal" href="converting_acc2omp/openacc2openmp.html#comparative-study-openacc-versus-openmp"><span class="std std-ref">Streaming Multiprocessor</span></a> has a constant cache. Because of this “per-SM” constant memory, reading takes less time as compared to reading directly from the constant memory.</p>
<p>The lifetime of a variable, which is declared and initialized on the constant memory, is equal to the lifetime of the program. A variable on the constant memory is accessible from any thread as long as the thread is from the same grid. The host can also read and write to the constant memory, but only through CUDA-Runtime functions. Variables on the constant memory must be pre-initialized before using them. Since the device code cannot write to the constant memory, the variables must be initialized from the host code using <code class="docutils literal notranslate"><span class="pre">cudaMemcpyToSymbol</span></code>, which is a CUDA-Runtime function.</p>
<p>Since our 2d-heat equation performs stencil operation which is a data-parallel operation and maps well to the GPU. Each thread calculates the change in temperature after a discrete time interval. During this calculation, each thread reads some constants, like the diffusion constant, time derivative etcetera. These constants tend to be the same throughout the execution of the program and would be a good candidate to use with constant memory.</p>
<p>To use the constant memory, we must setup it up from the host code, as shown in the code snippet. The highlighted line shows the copying of the data from the source to the constant memory on the device.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// constants array declaration using constant memory</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="n">__constant__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">constants</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="c1">// cell_size, alpha, dt</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="kt">void</span><span class="w"> </span><span class="nf">setup_constants</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">cell_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEFAULT_CELL_SIZE</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEFAULT_ALPHA</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cell_size</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">cell_size</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cell_size</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)));</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span>
<span class="linenos">10</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">host_constants</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">cell_size</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">};</span>
<span class="hll"><span class="linenos">11</span><span class="w">  </span><span class="n">check_cuda</span><span class="p">(</span><span class="n">cudaMemcpyToSymbol</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span><span class="w"> </span><span class="n">host_constants</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;Error constant memory&quot;</span><span class="w"> </span><span class="p">);</span>
</span><span class="linenos">12</span><span class="p">}</span>
</pre></div>
</div>
<p>Now, we must call the ‘setup_constants’ function before our ‘evolve’ kernel call, as shown here.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w">  </span><span class="c1">// Main calculation</span>
<span class="hll"><span class="linenos">2</span><span class="w">  </span><span class="n">setup_constants</span><span class="p">();</span>
</span><span class="linenos">3</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">start_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="p">();</span>
<span class="linenos">4</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">num_iter</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">5</span><span class="w">    </span><span class="c1">// One iteration of the heat equation</span>
<span class="linenos">6</span><span class="w">    </span><span class="c1">// evolve&lt;&lt;&lt;dim_grid, dim_block&gt;&gt;&gt;(grid, next_grid, grid_size, cell_size, alpha, dt);</span>
<span class="linenos">7</span><span class="w">    </span><span class="n">evolve</span><span class="o">&lt;&lt;&lt;</span><span class="n">dim_grid</span><span class="p">,</span><span class="w"> </span><span class="n">dim_block</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">next_grid</span><span class="p">,</span><span class="w"> </span><span class="n">grid_size</span><span class="p">);</span>
</pre></div>
</div>
<p>Since we setup up our coefficients through constant memory, we do not need to send them as the function  arguments during the kernel call.</p>
<p>The final thing remaining is to fetch the coefficients, on device, while doing computation. This can be done as shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">evolve</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="w">  </span>
<span class="linenos"> 7</span><span class="cp">#define CURR(i,j) curr[((i)+1)*(size+2)+(j)+1]</span>
<span class="linenos"> 8</span><span class="cp">#define NEXT(i,j) next[((i)+1)*(size+2)+(j)+1]</span>
<span class="linenos"> 9</span><span class="w">  </span>
<span class="linenos">10</span><span class="w">  </span><span class="c1">// Additional variables</span>
<span class="linenos">11</span><span class="w">  </span><span class="c1">// const float cell = cell_size * cell_size;</span>
<span class="linenos">12</span><span class="w">  </span><span class="c1">// const float r = alpha * dt;</span>
<span class="linenos">13</span>
<span class="hll"><span class="linenos">14</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">cell_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="hll"><span class="linenos">15</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">constants</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class="linenos">16</span>
<span class="linenos">17</span><span class="w">  </span><span class="c1">// When launching this kernel we don&#39;t take into account that we don&#39;t want</span>
<span class="linenos">18</span><span class="w">  </span><span class="c1">// it run for the boundary, we solve this by the following if guard, this</span>
<span class="linenos">19</span><span class="w">  </span><span class="c1">// means that we launch 4 threads more than we actually need, but this is a</span>
<span class="linenos">20</span><span class="w">  </span><span class="c1">// very low overhead</span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">23</span><span class="w">    </span><span class="n">NEXT</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span>
<span class="linenos">24</span><span class="w">                                 </span><span class="p">(</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span>
<span class="linenos">25</span><span class="w">                                  </span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="o">+</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span>
<span class="linenos">26</span><span class="w">                                  </span><span class="mf">4.0</span><span class="o">*</span><span class="n">CURR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">cell_size</span><span class="o">*</span><span class="n">cell_size</span><span class="p">)</span>
<span class="linenos">27</span><span class="w">                                 </span><span class="p">);</span>
<span class="linenos">28</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">29</span><span class="w">  </span>
<span class="linenos">30</span><span class="p">}</span>
<span class="linenos">31</span>
<span class="linenos">32</span><span class="c1">// Helper method to save the field to PNG</span>
<span class="linenos">33</span><span class="kt">void</span><span class="w"> </span><span class="n">save</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">field</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">iteration</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">34</span><span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">filename</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="linenos">35</span><span class="w">  </span><span class="n">sprintf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;field_%05d.png&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">iteration</span><span class="p">);</span>
</pre></div>
</div>
<p>The complete source file can be downloaded from the given link.</p>
<p><a class="reference download internal" download="" href="../../_downloads/3c4537a3dbc39ac7e73eadba3f202a9c/cuda_const.cu"><code class="xref download docutils literal notranslate"><span class="pre">cuda_const.cu</span></code></a></p>
<p>Let us re-run our code in the Nsight profiler.</p>
<figure class="align-center" id="id19">
<span id="fig-cuda-const"></span><a class="reference internal image-reference" href="../../_images/nnsconst8.png"><img alt="../../_images/nnsconst8.png" src="../../_images/nnsconst8.png" style="width: 700px;" />
</a>
<figcaption>
<p><span class="caption-text">Fig 14: CUDA constant memory.</span><a class="headerlink" href="#id19" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>If we compare results from <a class="reference internal" href="#fig-cuda-summary"><span class="std std-ref">figure 13</span></a> and <a class="reference internal" href="#fig-cuda-const"><span class="std std-ref">figure 14</span></a>, we see that some improvement was achieved during data transfer, and little time reduction has been noticed in the evolve kernel execution.</p>
<section id="debugging">
<span id="sec-2dheq-debugging"></span><h2>Debugging<a class="headerlink" href="#debugging" title="Link to this heading"></a></h2>
</section>
<p>In this section, we will show some of the basic techniques to use CUDA gdb. CUDA gdb is an extension of the gdb debugger, which adds support for CUDA debugging. It supports breakpoints, single stepping, and everything else you would expect from a debugger. CUDA-gdb can be used to debug both the device code, as-well-as the host code.</p>
<p>To start the debugging session, we must provide the <code class="docutils literal notranslate"><span class="pre">-G</span></code> flag to our nvcc compiler. The -G flag enables debug symbols just like it would in the GNU-C compiler.</p>
<p>To make it a little fast and easy, I have included a CUDA-gdb enabled version of our 2DHeatequation code. You just need to compile and run it like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>cuda-gdb
cuda<span class="w"> </span>gdb<span class="w"> </span>code<span class="w"> </span>is<span class="w"> </span>built

$<span class="w"> </span>srun<span class="w"> </span>--account<span class="o">=</span>&lt;UserAccount&gt;<span class="w"> </span>--nodes<span class="o">=</span><span class="m">1</span><span class="w"> </span>--ntasks-per-node<span class="o">=</span><span class="m">1</span><span class="w"> </span>--time<span class="o">=</span><span class="m">05</span>:00<span class="w"> </span>--qos<span class="o">=</span>devel<span class="w"> </span>--partition<span class="o">=</span>preproc<span class="w"> </span>./cuda-gdb
Submitted<span class="w"> </span>batch<span class="w"> </span>job<span class="w"> </span><span class="m">6990542</span>

$<span class="w"> </span>cat<span class="w"> </span>output.out
Waiting<span class="w"> </span><span class="k">for</span><span class="w"> </span>evolve<span class="w"> </span>before<span class="w"> </span>pointer<span class="w"> </span>swap:
<span class="w">	</span>Error<span class="o">(</span>cudaErrorIllegalAddress<span class="o">)</span>:<span class="w"> </span>an<span class="w"> </span>illegal<span class="w"> </span>memory<span class="w"> </span>access<span class="w"> </span>was<span class="w"> </span>encountered
</pre></div>
</div>
<p>So, from the output, we know that illegal memory access has occurred somewhere in the code, with no other information. Luckily, we have CUDA-gdb to rescue us from this situation.</p>
<p>Since the code was compiled using proper flags to load debug symbols, we just need to invoke the CUDA-gdb, like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cuda-gdb<span class="w"> </span>./cuda_gdb
</pre></div>
</div>
<p>The above command should start the gdb with command-line-interface, something similar to this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>NVIDIA<span class="w"> </span><span class="o">(</span>R<span class="o">)</span><span class="w"> </span>CUDA<span class="w"> </span>Debugger
<span class="m">11</span>.1<span class="w"> </span>release
Portions<span class="w"> </span>Copyright<span class="w"> </span><span class="o">(</span>C<span class="o">)</span><span class="w"> </span><span class="m">2007</span>-2020<span class="w"> </span>NVIDIA<span class="w"> </span>Corporation
GNU<span class="w"> </span>gdb<span class="w"> </span><span class="o">(</span>GDB<span class="o">)</span><span class="w"> </span><span class="m">8</span>.3.1
Copyright<span class="w"> </span><span class="o">(</span>C<span class="o">)</span><span class="w"> </span><span class="m">2019</span><span class="w"> </span>Free<span class="w"> </span>Software<span class="w"> </span>Foundation,<span class="w"> </span>Inc.
License<span class="w"> </span>GPLv3+:<span class="w"> </span>GNU<span class="w"> </span>GPL<span class="w"> </span>version<span class="w"> </span><span class="m">3</span><span class="w"> </span>or<span class="w"> </span>later<span class="w"> </span>&lt;http://gnu.org/licenses/gpl.html&gt;
This<span class="w"> </span>is<span class="w"> </span>free<span class="w"> </span>software:<span class="w"> </span>you<span class="w"> </span>are<span class="w"> </span>free<span class="w"> </span>to<span class="w"> </span>change<span class="w"> </span>and<span class="w"> </span>redistribute<span class="w"> </span>it.
There<span class="w"> </span>is<span class="w"> </span>NO<span class="w"> </span>WARRANTY,<span class="w"> </span>to<span class="w"> </span>the<span class="w"> </span>extent<span class="w"> </span>permitted<span class="w"> </span>by<span class="w"> </span>law.
Type<span class="w"> </span><span class="s2">&quot;show copying&quot;</span><span class="w"> </span>and<span class="w"> </span><span class="s2">&quot;show warranty&quot;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>details.
This<span class="w"> </span>GDB<span class="w"> </span>was<span class="w"> </span>configured<span class="w"> </span>as<span class="w"> </span><span class="s2">&quot;x86_64-pc-linux-gnu&quot;</span>.
Type<span class="w"> </span><span class="s2">&quot;show configuration&quot;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>configuration<span class="w"> </span>details.
For<span class="w"> </span>bug<span class="w"> </span>reporting<span class="w"> </span>instructions,<span class="w"> </span>please<span class="w"> </span>see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find<span class="w"> </span>the<span class="w"> </span>GDB<span class="w"> </span>manual<span class="w"> </span>and<span class="w"> </span>other<span class="w"> </span>documentation<span class="w"> </span>resources<span class="w"> </span>online<span class="w"> </span>at:
<span class="w">    </span>&lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For<span class="w"> </span>help,<span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="s2">&quot;help&quot;</span>.
Type<span class="w"> </span><span class="s2">&quot;apropos word&quot;</span><span class="w"> </span>to<span class="w"> </span>search<span class="w"> </span><span class="k">for</span><span class="w"> </span>commands<span class="w"> </span>related<span class="w"> </span>to<span class="w"> </span><span class="s2">&quot;word&quot;</span>...
Reading<span class="w"> </span>symbols<span class="w"> </span>from<span class="w"> </span>./cuda_gdb...
<span class="o">(</span>cuda-gdb<span class="o">)</span><span class="w"> </span>
</pre></div>
</div>
<p>Now, type <code class="docutils literal notranslate"><span class="pre">run</span></code>, this time we get a lot of vital information, and the execution would stop where it encountered the illegal memory access.</p>
<p>The information should look something similar to this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(cuda-gdb) run
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.
warning: File &quot;/cluster/apps/eb/software/GCCcore/10.2.0/lib64/libstdc++.so.6.0.28-gdb.py&quot; auto-loading has been declined by your `auto-load safe-path&#39; set to &quot;$debugdir:$datadir/auto-load&quot;.
To enable execution of this file add
	add-auto-load-safe-path /cluster/apps/eb/software/GCCcore/10.2.0/lib64/libstdc++.so.6.0.28-gdb.py
line to your configuration file &quot;/cluster/home/user/.cuda-gdbinit&quot;.
To completely disable this security protection add
	set auto-load safe-path /
line to your configuration file &quot;/cluster/home/user/.cuda-gdbinit&quot;.
For more information about this security protection see the
&quot;Auto-loading safe path&quot; section in the GDB manual.  E.g., run from the shell:
	info &quot;(gdb)Auto-loading safe path&quot;
Solving heat equation for grid 500 x 500 with 1000 iterations
Launching (32, 32) grids with (16, 16) blocks
[Detaching after fork from child process 1561068]
[New Thread 0x7fffef646000 (LWP 1561074)]
[New Thread 0x7fffeee45000 (LWP 1561075)]

CUDA Exception: Warp Illegal Address
The exception was triggered at PC 0x906110 (cuda_gdb.cu:209)

Thread 1 &quot;cuda_gdb&quot; received signal CUDA_EXCEPTION_14, Warp Illegal Address.
[Switching focus to CUDA kernel 0, grid 3, block (0,0,0), thread (1,1,0), device 0, sm 0, warp 1, lane 17]
0x0000000000906118 in evolve&lt;&lt;&lt;(32,32,1),(16,16,1)&gt;&gt;&gt; (curr=0x7fffbc000000, next=0x7fffbc0f6200, size=500, 
    cell_size=0.00999999978, alpha=0.100000001, dt=0.000249999983) at src/cuda_gdb.cu:209


</pre></div>
</div>
<p>Now, we know that the kernel ‘evolve’ is doing some illegal memory accesses. List the code around line number 209. We chose 209 because it is pointed out by the debugger. Since our <code class="docutils literal notranslate"><span class="pre">listsize</span></code> is set to 30, we would list the code from line number 200.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">(</span>cuda-gdb<span class="o">)</span><span class="w"> </span>list<span class="w"> </span><span class="m">200</span>
<span class="m">185</span><span class="w">	</span>
<span class="m">186</span><span class="w">	</span><span class="c1">#define CURR(i,j) curr[((i)-1)*(size)+(j)-1]</span>
<span class="m">187</span><span class="w">	</span><span class="c1">#define NEXT(i,j) next[((i))*(size+2)+(j)]</span>
<span class="m">188</span><span class="w">	</span>
<span class="m">189</span><span class="w">	  </span>
<span class="m">190</span><span class="w">	  </span>//<span class="w"> </span>Additional<span class="w"> </span>variables
<span class="m">191</span><span class="w">	  </span>const<span class="w"> </span>float<span class="w"> </span><span class="nv">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>cell_size<span class="w"> </span>*<span class="w"> </span>cell_size<span class="p">;</span>
<span class="m">192</span><span class="w">	  </span>const<span class="w"> </span>float<span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alpha<span class="w"> </span>*<span class="w"> </span>dt<span class="p">;</span>
<span class="m">193</span><span class="w">	  </span>//<span class="w"> </span>When<span class="w"> </span>launching<span class="w"> </span>this<span class="w"> </span>kernel<span class="w"> </span>we<span class="w"> </span>don<span class="s1">&#39;t take into account that we don&#39;</span>t<span class="w"> </span>want
<span class="m">194</span><span class="w">	  </span>//<span class="w"> </span>it<span class="w"> </span>run<span class="w"> </span><span class="k">for</span><span class="w"> </span>the<span class="w"> </span>boundary,<span class="w"> </span>we<span class="w"> </span>solve<span class="w"> </span>this<span class="w"> </span>by<span class="w"> </span>the<span class="w"> </span>following<span class="w"> </span><span class="k">if</span><span class="w"> </span>guard,<span class="w"> </span>this
<span class="m">195</span><span class="w">	  </span>//<span class="w"> </span>means<span class="w"> </span>that<span class="w"> </span>we<span class="w"> </span>launch<span class="w"> </span><span class="m">4</span><span class="w"> </span>threads<span class="w"> </span>more<span class="w"> </span>than<span class="w"> </span>we<span class="w"> </span>actually<span class="w"> </span>need,<span class="w"> </span>but<span class="w"> </span>this<span class="w"> </span>is<span class="w"> </span>a
<span class="m">196</span><span class="w">	  </span>//<span class="w"> </span>very<span class="w"> </span>low<span class="w"> </span>overhead
<span class="m">197</span><span class="w">	  </span>/*
<span class="m">198</span><span class="w">	  </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="m">0</span><span class="w"> </span>&lt;<span class="w"> </span>row<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>row<span class="w"> </span>&lt;<span class="w"> </span>size<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>&lt;<span class="w"> </span>col<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>col<span class="w"> </span>&lt;<span class="w"> </span>size<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="m">199</span><span class="w">	    </span>const<span class="w"> </span>int<span class="w"> </span><span class="nv">ip1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span>row<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span>*<span class="w"> </span><span class="o">(</span>size<span class="w"> </span>+<span class="w"> </span><span class="m">2</span><span class="o">)</span><span class="w"> </span>+<span class="w"> </span>col<span class="p">;</span>
<span class="m">200</span><span class="w">	    </span>const<span class="w"> </span>int<span class="w"> </span><span class="nv">im1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span>row<span class="w"> </span>-<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span>*<span class="w"> </span><span class="o">(</span>size<span class="w"> </span>+<span class="w"> </span><span class="m">2</span><span class="o">)</span><span class="w"> </span>+<span class="w"> </span>col<span class="p">;</span>
<span class="m">201</span><span class="w">	    </span>const<span class="w"> </span>int<span class="w"> </span><span class="nv">jp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>row<span class="w"> </span>*<span class="w"> </span><span class="o">(</span>size<span class="w"> </span>+<span class="w"> </span><span class="m">2</span><span class="o">)</span><span class="w"> </span>+<span class="w"> </span><span class="o">(</span>col<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="p">;</span>
<span class="m">202</span><span class="w">	    </span>const<span class="w"> </span>int<span class="w"> </span><span class="nv">jm1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>row<span class="w"> </span>*<span class="w"> </span><span class="o">(</span>size<span class="w"> </span>+<span class="w"> </span><span class="m">2</span><span class="o">)</span><span class="w"> </span>+<span class="w"> </span><span class="o">(</span>col<span class="w"> </span>-<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="p">;</span>
<span class="m">203</span><span class="w">	    </span>next<span class="o">[</span>index<span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>curr<span class="o">[</span>index<span class="o">]</span><span class="w"> </span>+<span class="w"> </span>r<span class="w"> </span>*
<span class="m">204</span><span class="w">	      </span><span class="o">((</span>curr<span class="o">[</span>ip1<span class="o">]</span><span class="w"> </span>-<span class="w"> </span><span class="m">2</span>.<span class="w"> </span>*<span class="w"> </span>curr<span class="o">[</span>index<span class="o">]</span><span class="w"> </span>+<span class="w"> </span>curr<span class="o">[</span>im1<span class="o">])</span><span class="w"> </span>/<span class="w"> </span>cell
<span class="m">205</span><span class="w">	      </span>+<span class="w"> </span><span class="o">(</span>curr<span class="o">[</span>jp1<span class="o">]</span><span class="w"> </span>-<span class="w"> </span><span class="m">2</span>.<span class="w"> </span>*<span class="w"> </span>curr<span class="o">[</span>index<span class="o">]</span><span class="w"> </span>+<span class="w"> </span>curr<span class="o">[</span>jm1<span class="o">])</span><span class="w"> </span>/<span class="w"> </span>cell<span class="o">)</span><span class="w"> </span><span class="p">;</span>
<span class="m">206</span><span class="w">	  </span><span class="o">}</span>*/
<span class="m">207</span><span class="w">	</span>
<span class="m">208</span><span class="w">	  </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="m">0</span><span class="w"> </span>&lt;<span class="w"> </span>i<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>i<span class="w"> </span>&lt;<span class="w"> </span>size<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>&lt;<span class="w"> </span>j<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>j<span class="w"> </span>&lt;<span class="w"> </span>size<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="m">209</span><span class="w">	    </span>NEXT<span class="o">(</span>i,j<span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>CURR<span class="o">(</span>i,j<span class="o">)</span><span class="w"> </span>+<span class="w"> </span>r<span class="w"> </span>*<span class="w"> </span><span class="o">(</span>
<span class="m">210</span><span class="w">	                                 </span><span class="o">(</span>CURR<span class="o">(</span>i-1,j<span class="o">)</span>+CURR<span class="o">(</span>i+1,j<span class="o">)</span>+
<span class="m">211</span><span class="w">	                                  </span>CURR<span class="o">(</span>i,j-1<span class="o">)</span>+CURR<span class="o">(</span>i,j+1<span class="o">)</span>-
<span class="m">212</span><span class="w">	                                  </span><span class="m">4</span>.0*CURR<span class="o">(</span>i,j<span class="o">))</span><span class="w"> </span>/<span class="w"> </span><span class="o">(</span>cell_size*cell_size<span class="o">)</span>
<span class="m">213</span><span class="w">	                                 </span><span class="o">)</span><span class="p">;</span>
<span class="m">214</span><span class="w">	  </span><span class="o">}</span>
</pre></div>
</div>
<p>We can see that there are some reads and writes in line number 209. We can also see that some macro functions perform read operations. Let us test which memory address they are reading from.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">(</span>cuda-gdb<span class="o">)</span><span class="w"> </span>p<span class="w"> </span>i
<span class="nv">$1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span>
<span class="o">(</span>cuda-gdb<span class="o">)</span><span class="w"> </span>p<span class="w"> </span>j
<span class="nv">$2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span>
<span class="o">(</span>cuda-gdb<span class="o">)</span><span class="w"> </span>p<span class="w"> </span>curr<span class="o">[((</span>i-1<span class="o">)</span>-1<span class="o">)</span>*<span class="o">(</span>size<span class="o">)</span>+<span class="o">(</span>j<span class="o">)</span>-1<span class="o">]</span>
Error:<span class="w"> </span>Failed<span class="w"> </span>to<span class="w"> </span><span class="nb">read</span><span class="w"> </span>generic<span class="w"> </span>memory<span class="w"> </span>at<span class="w"> </span>address<span class="w"> </span>0x7fffbbfff830<span class="w"> </span>on<span class="w"> </span>device<span class="w"> </span><span class="m">0</span><span class="w"> </span>sm<span class="w"> </span><span class="m">0</span><span class="w"> </span>warp<span class="w"> </span><span class="m">1</span><span class="w"> </span>lane<span class="w"> </span><span class="m">17</span>,<span class="w"> </span><span class="nv">error</span><span class="o">=</span>CUDBG_ERROR_INVALID_MEMORY_SEGMENT<span class="o">(</span>0x7<span class="o">)</span>.
</pre></div>
</div>
<p>We are trying to read the memory past the lower bound of our allocated memory space on the device and thus get the error. Fix this by replacing 1 with 2.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="m">1</span>.<span class="w"> </span><span class="c1">#define CURR(i,j) curr[((i)-1)*(size)+(j)-1]</span>
<span class="w"> </span>
<span class="m">2</span>.<span class="w"> </span><span class="c1">#define CURR(i,j) curr[((i))*(size)+(j)]</span>
</pre></div>
</div>
<section id="resources">
<span id="sec-2dheq-resources"></span><h2>Resources<a class="headerlink" href="#resources" title="Link to this heading"></a></h2>
</section>
<p>The complete code is available in compressed format and can be downloaded from the given link.</p>
<p><a class="reference download internal" download="" href="../../_downloads/cadf1dfc1ee4793314d0f5696e4062ad/HeatEq2D_Stencil.tar.gz"><code class="xref download docutils literal notranslate"><span class="pre">HeatEq2D_Stencil</span></code></a></p>
<section id="upload-it-to-betzy">
<span id="sec-copy"></span><h2>Upload it to Betzy<a class="headerlink" href="#upload-it-to-betzy" title="Link to this heading"></a></h2>
</section>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>scp<span class="w"> </span>&lt;source_directory/HeatEq2D_Stencil.tar.gz&gt;<span class="w"> </span>username@betzy.sigma2.no:/cluster/home/&lt;target_directory&gt;
</pre></div>
</div>
<section id="uncompress-it-on-betzy">
<span id="sec-uncompress"></span><h2>Uncompress it on Betzy<a class="headerlink" href="#uncompress-it-on-betzy" title="Link to this heading"></a></h2>
</section>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>tar<span class="w"> </span>-zxvf<span class="w"> </span>HeatEq2D_Stencil.tar.gz
</pre></div>
</div>
<section id="build-project-on-betzy">
<span id="sec-build"></span><h2>Build project on Betzy<a class="headerlink" href="#build-project-on-betzy" title="Link to this heading"></a></h2>
</section>
<p>Build <code class="docutils literal notranslate"><span class="pre">Serial</span></code> version.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>serial
</pre></div>
</div>
<p>Build <code class="docutils literal notranslate"><span class="pre">Parallel</span></code> version.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>parallel
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Module <code class="docutils literal notranslate"><span class="pre">CUDA/11.4.1</span></code> is required on Betzy to build GPU version.</p>
</div>
<p>Build <code class="docutils literal notranslate"><span class="pre">CUDA</span></code> version.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>cuda
</pre></div>
</div>
<p>Build complete project.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>all
</pre></div>
</div>
<section id="execute-code-on-betzy">
<span id="sec-execute"></span><h2>Execute code on Betzy<a class="headerlink" href="#execute-code-on-betzy" title="Link to this heading"></a></h2>
</section>
<p>Run <code class="docutils literal notranslate"><span class="pre">Serial</span></code> version.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>srun<span class="w"> </span>--account<span class="o">=</span>&lt;UserAccount&gt;<span class="w"> </span>--nodes<span class="o">=</span><span class="m">1</span><span class="w"> </span>--ntasks-per-node<span class="o">=</span><span class="m">1</span><span class="w"> </span>--time<span class="o">=</span><span class="m">05</span>:00<span class="w"> </span>--qos<span class="o">=</span>devel<span class="w"> </span>--partition<span class="o">=</span>preproc<span class="w"> </span>./serial
</pre></div>
</div>
<p>Run <code class="docutils literal notranslate"><span class="pre">Parallel</span></code> version.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>srun<span class="w"> </span>--account<span class="o">=</span>&lt;UserAccount&gt;<span class="w"> </span>--nodes<span class="o">=</span><span class="m">1</span><span class="w"> </span>--ntasks-per-node<span class="o">=</span><span class="m">1</span><span class="w"> </span>--cpus-per-task<span class="o">=</span><span class="m">32</span><span class="w"> </span>-c<span class="w"> </span><span class="m">32</span><span class="w"> </span>--time<span class="o">=</span><span class="m">05</span>:00<span class="w"> </span>--mem-per-cpu<span class="o">=</span>512M<span class="w"> </span>--qos<span class="o">=</span>devel<span class="w"> </span>--partition<span class="o">=</span>preproc<span class="w"> </span>./parallel<span class="w"> </span>
</pre></div>
</div>
<p>Run <code class="docutils literal notranslate"><span class="pre">CUDA</span></code> version.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>srun<span class="w"> </span>--account<span class="o">=</span>&lt;User-Account&gt;<span class="w"> </span>--partition<span class="o">=</span>accel<span class="w"> </span>--gpus-per-task<span class="o">=</span><span class="m">1</span><span class="w"> </span>--ntasks<span class="o">=</span><span class="m">1</span><span class="w"> </span>--time<span class="o">=</span><span class="m">05</span>:00<span class="w"> </span>--mem-per-cpu<span class="o">=</span>512M<span class="w">  </span>./cuda
</pre></div>
</div>
<section id="visualization-on-betzy">
<span id="sec-visualization"></span><h2>Visualization on Betzy<a class="headerlink" href="#visualization-on-betzy" title="Link to this heading"></a></h2>
</section>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>srun<span class="w"> </span>--account<span class="o">=</span>&lt;UserAccount&gt;<span class="w"> </span>--cpus-per-task<span class="o">=</span><span class="m">1</span><span class="w"> </span>-c<span class="w"> </span><span class="m">1</span><span class="w"> </span>--time<span class="o">=</span><span class="m">10</span>:00<span class="w"> </span>--mem-per-cpu<span class="o">=</span>1G<span class="w"> </span>--qos<span class="o">=</span>devel<span class="w"> </span>--partition<span class="o">=</span>preproc<span class="w"> </span>./serial<span class="w"> </span><span class="m">500</span><span class="w"> </span><span class="m">1000</span><span class="w"> </span><span class="m">2</span>
</pre></div>
</div>
<p>The above command will generate one <code class="docutils literal notranslate"><span class="pre">png</span></code> file at every other iteration, and then you can use <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code> to create animation.</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, Sigma2/NRIS. Text shared under CC-BY 4.0 license.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>