

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; Sigma2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/nris.css?v=69e7a171" />
      <link rel="stylesheet" type="text/css" href="../../_static/universal-navbar.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/statuspal.css" />

  
    <link rel="shortcut icon" href="../../_static/nris.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://siteimproveanalytics.com/js/siteanalyze_6036825.js"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../../_static/statuspal_widget.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">
<!-- Send url to parent when displayed as iframe -->
<script>
    const valid_orign_url = "https://www.sigma2.no"
    window.addEventListener('message', function(event) {
        if (event.data === 'getDocumentationIframeUrl' && event.origin.startsWith(valid_orign_url)) {
            // path only (/path/example.html)
            const path = window.location.pathname
            // query string (including the initial ? symbol)
            const search = window.location.search
            // Returns the hash (including the initial # symbol)
            const hash = window.location.hash
            const newUrl = path + search + hash;
            event.source.postMessage(newUrl, event.origin)
        }
    })

</script>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Sigma2/NRIS documentation
              <img src="../../_static/NRIS Logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Policies</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../code-of-conduct.html">Code of Conduct</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting help</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/support_line.html">Getting help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/extended_support.html">Extended support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/how_to_write_good_support_requests.html">Writing good support requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/qa-sessions.html">Open Question &amp; Answer Sessions for All Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/lost_forgotten_password.html">Lost, expiring or changing passwords</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/two_factor_authentication.html">One-time-pad (OTP) / Two-factor authentication</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.sigma2.no/project-leader-handbook">Project Leader Support</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Training</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../training/events.html">Training events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../training/notes_qa.html">Questions, Answers and Feedbacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../training/past_training.html">An overview over training events in the past</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../training/videos.html">Training Video Archives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../training/short_instructions.html">Short Instructions Video Archives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../training/material.html">Training materials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/opslog.html">Status and maintenance of systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/applying_account.html">How do I get an account?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/applying_resources.html">Applying for computing and storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/file_transfer.html">File transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/editing_files.html">Editing files</a></li>
<li class="toctree-l1"><a class="reference internal" href="vs_code/connect_to_server.html">Connecting to a system with Visual Studio Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/ssh.html">SSH</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/ssh.html#common-ssh-errors">Common SSH errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/ood.html">Open OnDemand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/R.html">First R calculation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Files, storage and backup</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/nird_lmd.html">NIRD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/clusters.html">Storage areas on HPC clusters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/quota.html">Storage quota</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/backup.html">Backup on Betzy, Fram, Saga, and NIRD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/sharing_files.html">Data handling and storage policy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../files_storage/performance.html">Optimizing storage performance</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">HPC usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/migration2metacenter.html">Migration to an NRIS HPC machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../computing/responsible-use.html">Using shared resources responsibly</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../jobs/overview.html">Running jobs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../jobs/internet-login-compute-nodes.html">Login nodes:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../jobs/internet-login-compute-nodes.html#compute-nodes">Compute nodes:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../computing/tuning-applications.html">Tuning applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides_llm.html">Running LLM Models in a Cluster Environment</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Compute resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/hardware_overview.html">Overview over our machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/betzy.html">Betzy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/fram.html">Fram</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/olivia.html">Olivia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/saga.html">Saga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_machines/lumi.html">LUMI</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Software</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../software/modulescheme.html">Software module scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software/installed_software.html">Installed software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software/userinstallsw.html">Installing software as user</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software/appguides.html">Application guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software/licenses.html">Licence and access policies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software/eessi.html">EESSI</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional services</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../nird_archive/sandbox-user-guide.html">NIRD Research Data Archive Sandbox (NIRD RDA sandbox)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nird_archive/user-guide.html">NIRD Research Data Archive (NIRD RDA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nird_toolkit/overview.html">NIRD Toolkit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nird_service_platform/overview_nird_service_platform.html">NIRD Service Platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../services/easydmp-user-documentation.html">EasyDMP User Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_help/course_resources.html">CRaaS - Course Resources as a Service</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Code development and tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Code development and tutorials</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Sigma2/NRIS documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Introduction</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="introduction">
<span id="index-0"></span><span id="ompoffload"></span><h1>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h1>
<p>This tutorial provides insights into the GPU programming using OpenMP (OMP) offload. The goal of this document is to quickly enable readers to run and test some OpenMP offload codes on <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a> platform. We assume that readers have previous knowledge of C/C++ programming, and are also aware of some of the commonly used OpenMP directives.</p>
<p>After reading this tutorial one should be able to answer:</p>
<ul class="simple">
<li><p>What is offloading in OpenMP?</p></li>
<li><p>How to compile OpenMP code with offloading support on <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a> platform?</p></li>
<li><p>How to invoke GPUs from the OpenMP code?</p></li>
<li><p>How to optimize the performance by using advanced features of the OpenMP library?</p></li>
</ul>
</section>
<section id="openmp-4-0">
<h1>OpenMP - 4.0<a class="headerlink" href="#openmp-4-0" title="Link to this heading"></a></h1>
<p>Let’s start with a short introduction to OpenMP-4.0. Heterogeneous systems, including Supercomputers, are optimized for low latency as well as for high throughput. The high throughput comes from the specialized co-processor, which we know by the name GPUs. In general, throughput is about the amount of data processed or transferred by a device in unit-time, whereas latency is about how fast the data can be transferred or loaded. Programmable GPUs offer a low Energy/Performance ratio, which is a good thing, but GPUs also expose issues related to <code class="docutils literal notranslate"><span class="pre">programmability</span></code>, <code class="docutils literal notranslate"><span class="pre">performance</span></code>, and <code class="docutils literal notranslate"><span class="pre">portability</span></code>. OpenMP 4.0 is thus an approach that enables resolving these three issues in one place.</p>
<p>OpenMP is a popular shared-memory parallel programming specification which pioneered the unification of proprietary languages into an industry standard. OpenMP 4.0 is the next step to expand its scope from traditional multicore CPUs to advanced programmable Accelerators. When OpenMP 4.0 was rolled out, it took a departure from the traditional <code class="docutils literal notranslate"><span class="pre">openmp</span></code> work-sharing constructs and added support for offloading tasks to other devices. Apart from several other key features in OpenMP 4.0, the major shift that distinguishes it from its predecessor is the ability to <code class="docutils literal notranslate"><span class="pre">offload</span></code>.</p>
<p>Now, what is offloading in the first place? <code class="docutils literal notranslate"><span class="pre">Offloading</span></code> often refers to taking the computation from the <code class="docutils literal notranslate"><span class="pre">Host</span></code> to the <code class="docutils literal notranslate"><span class="pre">Target</span></code>. The OMP program starts executing on the host, which is generally the CPU, and the computing task can be offloaded to the target device. The target device could be an accelerator or even the CPU itself. In this tutorial, we will focus on the GPUs as the target device; however, it is possible in OpenMP-4.0 to offload computation on other types of coprocessors, like FPGAs.</p>
</section>
<section id="clang-llvm-compiler-with-openmp-4-0-support">
<h1>Clang/LLVM compiler with OpenMP 4.0 support<a class="headerlink" href="#clang-llvm-compiler-with-openmp-4-0-support" title="Link to this heading"></a></h1>
<p>Many compilers support OpenMP 4.0, 4.5, and 5.0 directives and are targeted at NVIDIA GPUs; one of the most prevalent hardware GPUs. <code class="docutils literal notranslate"><span class="pre">Clang</span></code> compiler is among the ones that are really moving quickly in accommodating OpenMP offload features. It is a collaborative effort of multiple vendors, like IBM, TI, Intel to bring OpenMP to Clang. Other compilers such as GCC have also some support for OpenMP 4.0; however, the performance might be limited depending on the compiler’s version.</p>
</section>
<section id="clang-on-betzy">
<span id="clang11"></span><h1>Clang on Betzy<a class="headerlink" href="#clang-on-betzy" title="Link to this heading"></a></h1>
<p>Building the Clang compiler with OpenMP-offload and Nvidia support is a chore at this point. It takes a lot of work to get it to work with NVIDIA-GPUs. Luckily, now Clang with OpenMP-offload is available on <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a> for its users.
The Clang compiler can be made available on <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a> using the following command.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>module<span class="w"> </span>load<span class="w"> </span>Clang/11.0.1-gcccuda-2020b
</pre></div>
</div>
</section>
<section id="case-study">
<h1>Case study.<a class="headerlink" href="#case-study" title="Link to this heading"></a></h1>
<p>For the sake of consistency, we will use the same <a class="reference external" href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot</a> example that has been used in the <a class="reference internal" href="async_openacc.html#asyncopenacc"><span class="std std-ref">OpenACC</span></a> tutorial. We will go through the code and incrementally add OpenMP directives so that the user can write an OpenMP-offload code without any apparent effort.</p>
<p>Now, we focus our attention on the <code class="docutils literal notranslate"><span class="pre">mandelbrot.c</span></code> code. For the convenience of our readers, we have copied the <code class="docutils literal notranslate"><span class="pre">mandelbrot.c</span></code> code down below.</p>
<div class="admonition note" id="mandelbrot-c">
<p class="admonition-title">Note</p>
<p>The complete code is provided at the bottom of this page, under resources section.</p>
</div>
<p><a class="reference download internal" download="" href="../../_downloads/8cad6f1a82f67cbb7534d8fc3479bce1/mandelbrot_serial.c"><code class="xref download docutils literal notranslate"><span class="pre">mandelbrot_serial.c</span></code></a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Mandelbrot implementation for accelerators (e.g. GPUs)</span>
<span class="cm"> */</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;utils/lodepng.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;utils/palette.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="c1">// Default width and height for image if not given</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">WIDTH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1280</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">HEIGHT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">720</span><span class="p">;</span>
<span class="c1">// Default output name if not given</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">OUTPUT_NAME</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mandelbrot.png&quot;</span><span class="p">;</span>
<span class="c1">// Maximum iteration count before exiting mandelbrot function</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">MAX_ITER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>

<span class="c1">// Helper function to scale &#39;num&#39; to the range &#39;[min, max]&#39;</span>
<span class="kt">float</span><span class="w"> </span><span class="nf">scale</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">min</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">max</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">min</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">min</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Mandelbrot function, calculates the value of the mandelbrot set at pixel &#39;px/py&#39;</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">mandelbrot</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">px</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">py</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">,</span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">max_iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scale</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">px</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scale</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">py</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">);</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">x2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">4.</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">max_iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y0</span><span class="p">;</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x0</span><span class="p">;</span>
<span class="w">    </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">y2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="n">iters</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WIDTH</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HEIGHT</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">output_name</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">max_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX_ITER</span><span class="p">;</span>
<span class="w">  </span><span class="n">strncpy</span><span class="w"> </span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">strnlen</span><span class="w"> </span><span class="p">(</span><span class="n">OUTPUT_NAME</span><span class="p">,</span><span class="w"> </span><span class="mi">127</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Assume the first argument is the width and height of the image</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strncmp</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;-h&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">strncmp</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;--help&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Usage: %s &lt;width&gt;x&lt;height&gt; &lt;max iterations&gt; &lt;output filename&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Image size can also be one of {8k, 4k, 3k, 1080p, 720p}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// First we check image size is one of the predefined sizes</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strncmp</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;8k&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7680</span><span class="p">;</span>
<span class="w">      </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4320</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strncmp</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;4k&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3840</span><span class="p">;</span>
<span class="w">      </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2160</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strncmp</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;3k&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3000</span><span class="p">;</span>
<span class="w">      </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2000</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strncmp</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;1080p&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1920</span><span class="p">;</span>
<span class="w">      </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1080</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strncmp</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;720p&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1280</span><span class="p">;</span>
<span class="w">      </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">720</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Assume user has supplied &lt;width&gt;x&lt;height&gt;</span>
<span class="w">      </span><span class="c1">// Try to find &#39;x&#39; in argument</span>
<span class="w">      </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">token</span><span class="p">;</span>
<span class="w">      </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strtok</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">token</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="w"> </span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[0;31mInvalid width/height definition:</span><span class="se">\033</span><span class="s">[0m &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Should be &#39;&lt;width&gt;x&lt;height&gt;&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strtok</span><span class="w"> </span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">token</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="w"> </span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[0;31mInvalid width/height definition:</span><span class="se">\033</span><span class="s">[0m &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Should be &#39;&lt;width&gt;x&lt;height&gt;&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Second argument is the maximum iteration count</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">max_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Third argument is the output filename to write PNG file to</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strlen</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">127</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[0;31mOutput filename to large!</span><span class="se">\033</span><span class="s">[0m&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">strncpy</span><span class="w"> </span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">strnlen</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="mi">127</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Allocate storage for image</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="w"> </span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">image</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[0;31mCould not allocate memory for image!</span><span class="se">\033</span><span class="s">[0m</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Generating </span><span class="se">\033</span><span class="s">[0;35m%dx%d</span><span class="se">\033</span><span class="s">[0m image with max </span><span class="se">\033</span><span class="s">[0;35m%d</span><span class="se">\033</span><span class="s">[0m iterations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">         </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span>
<span class="w">         </span><span class="n">max_iter</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/****************************************************************************/</span>
<span class="w">  </span><span class="cm">/***************************   Main computation   ***************************/</span>
<span class="w">  </span><span class="cm">/****************************************************************************/</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">start_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="w"> </span><span class="p">();</span>
<span class="w">  </span><span class="c1">// For each pixel of our image calculate the value of the mandelbrot set</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mandelbrot</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="p">);</span>
<span class="w">      </span><span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">palette</span><span class="p">[</span><span class="n">iters</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">palette_size</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">end_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="w"> </span><span class="p">();</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Used </span><span class="se">\033</span><span class="s">[0;35m%.3f</span><span class="se">\033</span><span class="s">[0m ms for computation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">         </span><span class="p">(</span><span class="n">end_time</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1000.0</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/****************************************************************************/</span>
<span class="w">  </span><span class="c1">// Write image to file</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">png_error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lodepng_encode32_file</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span>
<span class="w">                                                        </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">image</span><span class="p">,</span>
<span class="w">                                                        </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Free image storage</span>
<span class="w">  </span><span class="n">free</span><span class="w"> </span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">png_error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[0;31mAn error occurred while writing to PNG:</span><span class="se">\033</span><span class="s">[0m %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">           </span><span class="n">lodepng_error_text</span><span class="w"> </span><span class="p">(</span><span class="n">png_error</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Wrote Mandelbrot result to </span><span class="se">\033</span><span class="s">[0;35m%s</span><span class="se">\033</span><span class="s">[0m</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">output_name</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The Mandelbrot set is a well-known function that refers to fractal sets. It has the form:</p>
<div class="math notranslate nohighlight">
\[f_{c}(z)=z^{2}+c\]</div>
<p>In short, the <a class="reference internal" href="#mandelbrot-c"><span class="std std-ref">mandelbrot.c</span></a> file produces a fractal picture using the mandelbrot function, in which the function generates the Mandelbrot set of complex numbers at a given pixel. Further reading can be found at <a class="reference external" href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot</a>.</p>
<p>Here is how the actual code looks like, and the highlighted lines show how the pixel value is updated with the mandelbrot value.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="cm">/****************************************************************************/</span>
<span class="w">  </span><span class="cm">/***************************   Main computation   ***************************/</span>
<span class="w">  </span><span class="cm">/****************************************************************************/</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">start_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="w"> </span><span class="p">();</span>
<span class="w">  </span><span class="c1">// For each pixel of our image calculate the value of the mandelbrot set</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="hll"><span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mandelbrot</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="p">);</span>
</span><span class="hll"><span class="w">      </span><span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">palette</span><span class="p">[</span><span class="n">iters</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">palette_size</span><span class="p">];</span>
</span><span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">end_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="w"> </span><span class="p">();</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Used </span><span class="se">\033</span><span class="s">[0;35m%.3f</span><span class="se">\033</span><span class="s">[0m ms for computation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">         </span><span class="p">(</span><span class="n">end_time</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1000.0</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/****************************************************************************/</span>
</pre></div>
</div>
</section>
<section id="openmp-on-cpu">
<h1>OpenMP on CPU.<a class="headerlink" href="#openmp-on-cpu" title="Link to this heading"></a></h1>
<p>Let’s look at our code again with a special focus on the highlighted region. Here, it can be seen that there is a nested for loop. The first ‘y’ loop scans the pixels of the image vertically, and the inner loop ‘x’ scans the image horizontally. In this way, the whole image is scanned pixel by pixel. For each pixel, the mandelbrot function is called and the old pixel value is swapped with the new value.</p>
<p>As we are using serial code, the first step is to see how much time a serial implementation would take on the CPU without any parallelization.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We assume that <code class="docutils literal notranslate"><span class="pre">Clang</span></code> compiler is already loaded in your work environment; as it is mentioned <a class="reference internal" href="#clang11"><span class="std std-ref">above</span></a>.</p>
</div>
<p>The serial version of the program can be compiled and run by using the following commands on  <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>serial
$<span class="w"> </span>srun<span class="w"> </span>--ntasks<span class="o">=</span><span class="m">1</span><span class="w"> </span>--account<span class="o">=</span>&lt;your<span class="w"> </span>project<span class="w"> </span>number&gt;<span class="w"> </span>--time<span class="o">=</span><span class="m">00</span>:10:00<span class="w"> </span>--mem-per-cpu<span class="o">=</span>125M<span class="w"> </span>--partition<span class="o">=</span>accel<span class="w"> </span>./serial
</pre></div>
</div>
<p>We found that executing a <code class="docutils literal notranslate"><span class="pre">1280x720</span></code> pixels image with <code class="docutils literal notranslate"><span class="pre">10,000</span></code> iterations takes <code class="docutils literal notranslate"><span class="pre">8</span></code> seconds.</p>
<p>Let’s build upon this and start applying OpenMP directives to transform our serial code into a parallel code on the CPU. As we know, the potential parallelizable region is the code with the nested ‘for’ loop, as shown in the figure.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="cm">/****************************************************************************/</span>
<span class="w">  </span><span class="cm">/***************************   Main computation   ***************************/</span>
<span class="w">  </span><span class="cm">/****************************************************************************/</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">start_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="w"> </span><span class="p">();</span>
<span class="w">  </span><span class="c1">// For each pixel of our image calculate the value of the mandelbrot set</span>
<span class="hll"><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span class="hll"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span class="hll"><span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mandelbrot</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="p">);</span>
</span><span class="hll"><span class="w">      </span><span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">palette</span><span class="p">[</span><span class="n">iters</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">palette_size</span><span class="p">];</span>
</span><span class="hll"><span class="w">    </span><span class="p">}</span>
</span><span class="hll"><span class="w">  </span><span class="p">}</span>
</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">end_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="w"> </span><span class="p">();</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Used </span><span class="se">\033</span><span class="s">[0;35m%.3f</span><span class="se">\033</span><span class="s">[0m ms for computation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">         </span><span class="p">(</span><span class="n">end_time</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1000.0</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/****************************************************************************/</span>
</pre></div>
</div>
<p>Let’s start off by parallelizing the code on the CPU using regular OMP directives. We will also use this implementation to benchmark our OMP(GPU) code. The OMP(CPU) compilers are very well tested and optimized for high performance, in addition, it is very easy to use: we simply need to type <code class="docutils literal notranslate"><span class="pre">omp</span> <span class="pre">parallel</span></code> before the first ‘for’ loop. Introducing the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> directive allows the compiler to spawn a team of threads; it won’t parallelize anything but executes the same code on multiple threads.</p>
<p>On <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a>, the execution time with the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> directive takes 15 seconds, which is higher than the value obtained using the <code class="docutils literal notranslate"><span class="pre">serial</span></code> version of our code.</p>
<p>We proceed by adding another directive: <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">for</span></code>. This is the work-sharing construct that divides the work across the number of threads in a group.</p>
<p>Here we go, with the use of the <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">for</span></code> clause, the code takes 0.54 seconds to execute. The performance is improved by a factor of 20 compared to the serial case.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="cp">#pragma omp parallel for</span>
</span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="hll"><span class="cp">#pragma omp parallel for</span>
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mandelbrot</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="p">);</span>
<span class="w">            </span><span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">palette</span><span class="p">[</span><span class="n">iters</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">palette_size</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Thread creation is an expensive operation, thread synchronization is also a point of concern which may deteriorate the overall performance. So, don’t let the compiler do all the optimizations for you; use OpenMP wisely.</p>
</div>
<p>Let’s move ahead with <code class="docutils literal notranslate"><span class="pre">omp</span> <span class="pre">offload</span></code>.</p>
</section>
<section id="openmp-on-gpu">
<h1>OpenMP on GPU.<a class="headerlink" href="#openmp-on-gpu" title="Link to this heading"></a></h1>
<p>In leveraging the high throughput capability of the GPUs, OpenMP 4.0 offers special constructs which take the compute-intensive tasks from the CPU, perform computation on the GPU and bring the computed result back to the CPU. The main motivation behind these heterogeneous architecture-specific constructs is to provide performance and portability in one place. A user doesn’t need to know the low-level accelerator-specific language before writing their device-specific code. Also, general-purpose and special-purpose code can be maintained in one place, thus the ‘offloading’ offloads some of the programmer’s work too.</p>
<p>Accelerator-specific code starts with <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">omp</span> <span class="pre">target</span></code> directive. The region within the <code class="docutils literal notranslate"><span class="pre">target</span></code> scope is also called the target region. As soon as the host thread reaches the target region, a new target thread gets created. Before doing any computation, the required data must also be mapped to the target device. OpenMP uses the <code class="docutils literal notranslate"><span class="pre">map</span></code> keyword to transfer data <code class="docutils literal notranslate"><span class="pre">to</span></code> and <code class="docutils literal notranslate"><span class="pre">from</span></code> the GPUs. Devices have their own memory space where they can store variables and data. It is important to note that the host thread can’t access the device thread or the device data. Also, OpenMP executes the target region in a blocking step, which means the CPU threads wait for the execution of the target region to finish before continuing the execution on the CPU. However, it is possible to override the default blocking mechanism into a nonblocking one. It is also interesting that we can use regular OpenMP directives, like <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">for</span></code>, within the target region.</p>
<p>Now we have enough theory to get our feet wet with the <code class="docutils literal notranslate"><span class="pre">Offloading</span></code> code.</p>
<p>For the OMP(GPU), we are going to use the <code class="docutils literal notranslate"><span class="pre">target</span></code> directive. The GPU/Accelerator-specific code is encompassed between the target region. The target region guarantees that the <code class="docutils literal notranslate"><span class="pre">target</span></code> directive takes your thread of execution to the target device. The target device could be another CPU, GPU, DSP, or FPGA; in a broader sense, the <code class="docutils literal notranslate"><span class="pre">target</span></code> directive takes the thread of execution and moves it elsewhere. Here one important thing to note is that the program starts executing on the host device, and when the <code class="docutils literal notranslate"><span class="pre">target</span></code> construct is hit by the main thread, a new thread is spawned, we call this thread <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">initial</span> <span class="pre">thread</span></code>. This initial thread executes on the target device, and when this new initial thread hits a parallel construct within the target region, it becomes the master thread. It is something different from the regular OpenMP where there was only one initial thread. It is also important to note that the new initial thread may or may not run on the GPU, depending on the condition of whether the GPU support is available on the system or not. If there is no GPU available on the system then the <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">initial</span> <span class="pre">thread</span></code> will run on the host device. To be sure if the thread is running on the GPU or CPU, one could use <code class="docutils literal notranslate"><span class="pre">omp_is_initial_device()</span></code>. The function returns false if the thread is running on the GPU.</p>
<p>The minimal example with OMP(offload) is shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="cp">#pragma omp target</span>
</span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span><span class="w">                                                                                                              </span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mandelbrot</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="p">);</span>
<span class="w">            </span><span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">palette</span><span class="p">[</span><span class="n">iters</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">palette_size</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">Clang</span></code> compiler should be available in your <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a> work-environment to compile/run the code, as it is mentioned <a class="reference internal" href="#clang11"><span class="std std-ref">here</span></a>. Or simply copy/paste the following command on <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a> terminal.</p>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>module<span class="w"> </span>load<span class="w"> </span>Clang/11.0.1-gcccuda-2020b
</pre></div>
</div>
<p>In our case-study, we create a Makefile, which helps building the code in a simplified way using the <code class="docutils literal notranslate"><span class="pre">Make</span></code> command. To build the code with OMP(offload) support, one must type <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">offload</span></code> on the terminal. The users have to make sure that all the required modules are loaded into the environment before building the code.</p>
<p>The bare minimum offload-code takes 148 seconds, which is almost 14 times slower than the <code class="docutils literal notranslate"><span class="pre">serial</span></code> version of the code. This is because the code is running on only one thread on the GPU and is not exploiting the entire GPU-accelerator. Moreover, the time cost of the data transfer between CPU and GPU has also been added up to the computation cost.</p>
<p>Let’s try to improve our code by adding <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct. The <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct starts a group of threads on the device, each group is called a “team” in the OpenMP terminology. This is somewhat similar to the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> construct, but the main difference is that in the <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct, each thread forms its team, that is a team of only one thread. Threads within different teams are restricted to a synchronisation with each other, that is, inter-team synchronisation is not possible; however, threads can synchronise within a team.</p>
<p id="targetteams">Now let’s try to run our code with <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="cp">#pragma omp target teams</span>
</span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w">                                                                                                              </span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mandelbrot</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="p">);</span>
<span class="w">            </span><span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">palette</span><span class="p">[</span><span class="n">iters</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">palette_size</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Remember to rebuild the code before running.</p>
<p>It turns out that introducing the concept of <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct has increased the computation cost to 154 seconds compared to 148 seconds in the previous version. What could be the reason behind this degradation? Well, spawning threads involves some cost. Here, all threads are computing only the same thing, which causes the observed low performance.</p>
<p>In regular OpenMP, when the main thread hits the parallel construct it becomes the master thread, and thus only one master thread gets created. As mentioned in the previous discussion, the <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct forms a group of initial threads where each thread forms its team. When each initial thread hits the ‘parallel construct’ then it becomes the master thread of the team, and in this way multiple master threads get formed. Under the cooperation of the individual master team thread, each thread executes the parallel region simultaneously.</p>
<p>Let’s put our multiple threads to work by applying the <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">for</span></code> construct.</p>
<p>Code example is shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="cp">#pragma omp target teams</span>
</span><span class="hll"><span class="cp">#pragma omp parallel for</span>
</span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w">                                                                                                              </span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mandelbrot</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="p">);</span>
<span class="w">            </span><span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">palette</span><span class="p">[</span><span class="n">iters</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">palette_size</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let’s rebuild and run the code.</p>
<p>We see a significant improvement when using the <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">for</span></code> construct. In this case, the code takes 2.3 seconds to run, which is 67 times faster than our previous version of the code.</p>
<p>One more thing we can do to optimize the <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">for</span></code> is to use the <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause. The <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause unrolls the nested loops into a single iteration space. We now try to test how this clause improves the performance of the code.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="cp">#pragma omp target teams</span>
</span><span class="hll"><span class="cp">#pragma omp parallel for collapse(2)</span>
</span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w">                                                                                                              </span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mandelbrot</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="p">);</span>
<span class="w">            </span><span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">palette</span><span class="p">[</span><span class="n">iters</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">palette_size</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is found that the use of the <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause affects slightly the performance, and now the computation cost is reduced to 2.2 seconds.</p>
<p>Can we get any better at improving our current code? Let’s try the <code class="docutils literal notranslate"><span class="pre">Distribute</span></code> construct. The <code class="docutils literal notranslate"><span class="pre">Distribute</span></code> construct is a work-sharing construct that distributes the iterations of the loop across the teams of threads; remember, <a class="reference internal" href="#targetteams"><span class="std std-ref">here</span></a>  we started the teams of threads by using <code class="docutils literal notranslate"><span class="pre">target</span> <span class="pre">teams</span></code> construct ?</p>
<p>It is also possible to schedule the loop iterations into chunks using the <code class="docutils literal notranslate"><span class="pre">Schedule</span></code> clause.</p>
<p>Let’s try the final version of our code where we apply all improvements in one place.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="cp">#pragma omp target teams distribute parallel for collapse(2) schedule(static, 1)</span>
</span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w">                                                                                                              </span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mandelbrot</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="p">);</span>
<span class="w">            </span><span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">palette</span><span class="p">[</span><span class="n">iters</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">palette_size</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The final version of our code takes 0.14 seconds for the computation, which is almost 16 times faster than our previous improvement.</p>
<p>In our experiment, the first optimized OMP(CPU) code takes 0.54 seconds. We thus use it as a benchmark study to evaluate the performance of the OMP(GPU) code. So, the conclusion is that OMP(GPU) is almost 4 times faster than the OMP(CPU) version.</p>
<p>We are still missing one major part of the OpenMP-Offload, and that is offloading the data to the device. To do the computation somewhere else, we would also require the data on which the computation is going to happen. Since OpenMP supports both ‘distributed’ and ‘shared’ memory architecture, implicit as well as explicit mapping of the variables is possible. In the ‘implicit’ mapping, the compiler decides which variables are going to be sent <code class="docutils literal notranslate"><span class="pre">to</span></code> or <code class="docutils literal notranslate"><span class="pre">from</span></code> the device, whereas in the ‘explicit mapping’, user must use <code class="docutils literal notranslate"><span class="pre">map</span></code> clause within the target region to explicitly map list variables ‘to’, ‘from’ device data environment. A mapped variable may either be in the shared or the distributed memory, and in some cases a copy is required which is determined by OpenMP implementation.
Note that once the data is moved to the device, the device owns it. And it is not possible to reference the data directly from the CPU. To access the device data one needs to bring the data back to the CPU from the device.</p>
<p>After incorporating the <code class="docutils literal notranslate"><span class="pre">map</span></code> clause, our code looks like this :</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="cp">#pragma omp target data map(to:palette[0:palette_size]), map(from:image[0:width*height])  </span>
</span><span class="p">{</span><span class="w">	</span>
<span class="cp">#pragma omp target teams distribute parallel for collapse(2) schedule(static, 1)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span><span class="w">                                                                                                              </span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mandelbrot</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="p">);</span>
<span class="w">                </span><span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">palette</span><span class="p">[</span><span class="n">iters</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">palette_size</span><span class="p">];</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At this point, we conclude that GPUs are optimized for the <code class="docutils literal notranslate"><span class="pre">throughput</span></code> whereas CPUs are optimized for the <code class="docutils literal notranslate"><span class="pre">latency</span></code>. Therefore, to benefit from using GPUs, we must give enough tasks to process per unit time on the GPU. In our code example, for instance, we care more about pixels per second than the latency of any particular pixel.</p>
<p>To highlight the benefit of using GPUs, we consider an example, in which the size of our input image is increased. As previously, we rerun the code on the GPU as well as on the CPU.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>omp
$<span class="w"> </span>srun<span class="w"> </span>--account<span class="o">=</span>&lt;your<span class="w"> </span>project<span class="w"> </span>number&gt;<span class="w"> </span>--cpus-per-task<span class="o">=</span><span class="m">32</span><span class="w"> </span>-c<span class="w"> </span><span class="m">32</span><span class="w"> </span>--time<span class="o">=</span><span class="m">10</span>:00<span class="w"> </span>--mem-per-cpu<span class="o">=</span>1G<span class="w"> </span>--qos<span class="o">=</span>devel<span class="w"> </span>--partition<span class="o">=</span>accel<span class="w"> </span>./omp<span class="w"> </span>8k<span class="w"> </span><span class="m">10000</span>
</pre></div>
</div>
<p>The processing time on the CPU is 19.5 seconds.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>offload<span class="w"> </span>
$<span class="w"> </span>srun<span class="w"> </span>--ntasks<span class="o">=</span><span class="m">1</span><span class="w"> </span>--time<span class="o">=</span><span class="m">10</span>:00<span class="w"> </span>--account<span class="o">=</span>&lt;your<span class="w"> </span>project<span class="w"> </span>number&gt;<span class="w"> </span>--mem-per-cpu<span class="o">=</span>1G<span class="w"> </span>--partition<span class="o">=</span>accel<span class="w"> </span>--gpus<span class="o">=</span><span class="m">1</span><span class="w"> </span>./offload<span class="w"> </span>8k<span class="w"> </span><span class="m">10000</span>
</pre></div>
</div>
<p>Processing time on the GPU is 0.27 seconds.</p>
<p>Our numerical experiment shows that running the code on the GPU is 72 times faster than on the multi-core CPU.</p>
</section>
<section id="summary-of-the-execution-times">
<h1>Summary of the execution times<a class="headerlink" href="#summary-of-the-execution-times" title="Link to this heading"></a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The benchmarking was performed on <a class="reference internal" href="../../hpc_machines/saga.html#saga"><span class="std std-ref">Saga</span></a> and not on <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a>, and you may find a slight difference in the execution times on <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a>.</p>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Image Size</p></th>
<th class="head"><p>Iterations</p></th>
<th class="head"><p>OMP-Directive</p></th>
<th class="head"><p>CPU time in ms.</p></th>
<th class="head"><p>GPU time in ms.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1280x720</p></td>
<td><p>10,000</p></td>
<td><p>–</p></td>
<td><p>10869.028</p></td>
<td><p>–</p></td>
</tr>
<tr class="row-odd"><td><p>1280x720</p></td>
<td><p>10,000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">parallel</span></code></p></td>
<td><p>15025.200</p></td>
<td><p>–</p></td>
</tr>
<tr class="row-even"><td><p>1280x720</p></td>
<td><p>10,000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">for</span></code></p></td>
<td><p>542.429</p></td>
<td><p>–</p></td>
</tr>
<tr class="row-odd"><td><p>1280x720</p></td>
<td><p>10,000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">target</span></code></p></td>
<td><p>–</p></td>
<td><p>147998.497</p></td>
</tr>
<tr class="row-even"><td><p>1280x720</p></td>
<td><p>10,000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">target</span> <span class="pre">teams</span></code></p></td>
<td><p>–</p></td>
<td><p>153735.213</p></td>
</tr>
<tr class="row-odd"><td><p>1280x720</p></td>
<td><p>10,000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">target</span> <span class="pre">teams</span> <span class="pre">parallel</span> <span class="pre">for</span></code></p></td>
<td><p>–</p></td>
<td><p>2305.166</p></td>
</tr>
<tr class="row-even"><td><p>1280x720</p></td>
<td><p>10,000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">target</span> <span class="pre">teams</span> <span class="pre">parallel</span> <span class="pre">for</span> <span class="pre">collapse</span></code></p></td>
<td><p>–</p></td>
<td><p>2296.626</p></td>
</tr>
<tr class="row-odd"><td><p>1280x720</p></td>
<td><p>10,000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">target</span> <span class="pre">teams</span> <span class="pre">distribute</span> <span class="pre">parallel</span> <span class="pre">for</span> <span class="pre">collapse</span> <span class="pre">schedule</span></code></p></td>
<td><p>–</p></td>
<td><p>143.434</p></td>
</tr>
<tr class="row-even"><td><p>8K</p></td>
<td><p>10,000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">for</span></code></p></td>
<td><p>19591.378</p></td>
<td><p>–</p></td>
</tr>
<tr class="row-odd"><td><p>8k</p></td>
<td><p>10,000</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">target</span> <span class="pre">teams</span> <span class="pre">distribute</span> <span class="pre">parallel</span> <span class="pre">for</span> <span class="pre">collapse</span> <span class="pre">schedule</span></code></p></td>
<td><p>–</p></td>
<td><p>268.179</p></td>
</tr>
</tbody>
</table>
</section>
<section id="resources">
<h1>Resources<a class="headerlink" href="#resources" title="Link to this heading"></a></h1>
<p>The complete code is available in compressed format and can be downloaded from the given link.</p>
<p><a class="reference download internal" download="" href="../../_downloads/0c1656603fcc9bc29011507fab75537b/mandelbrot_gpu.tar.gz"><code class="xref download docutils literal notranslate"><span class="pre">mandelbrot_gpu.tar.gz</span></code></a></p>
<p>One can download the given <code class="docutils literal notranslate"><span class="pre">tarball</span></code> file on his/her computer and copy it to <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a> using <code class="docutils literal notranslate"><span class="pre">scp</span></code> command, as shown below.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>scp<span class="w"> </span>&lt;source_directory/mandelbrot_gpu.tar.gz&gt;<span class="w"> </span>username@betzy.sigma2.no:/cluster/home/&lt;target_directory&gt;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">source</span> <span class="pre">directory</span></code> should be the absolute path of the downloaded <code class="docutils literal notranslate"><span class="pre">tarball</span></code> on your computer, and the target directory should be the directory where you want to keep and uncompress the <code class="docutils literal notranslate"><span class="pre">tarball</span></code>.</p>
<p>To uncompress the <code class="docutils literal notranslate"><span class="pre">tarball</span></code> file, execute the following command on the terminal.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>tar<span class="w"> </span>-zxvf<span class="w"> </span>mandelbrot_gpu.tar.gz
</pre></div>
</div>
</section>
<section id="makefile">
<h1>Makefile<a class="headerlink" href="#makefile" title="Link to this heading"></a></h1>
<p>For our sample code, we used <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> to build. <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> contains all the code that is needed to automate the boring task of transforming the source code into an executable. One could argue; why not <code class="docutils literal notranslate"><span class="pre">batch</span></code> script? The advantage of <code class="docutils literal notranslate"><span class="pre">make</span></code> over the script is that one can specify the relationships between the elements of the program to <code class="docutils literal notranslate"><span class="pre">make</span></code>, and through this relationship together with timestamps it can figure out exactly what steps need to be repeated to produce the desired program each time. In short, it saves time by optimizing the build process.</p>
<p>A brief version of the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> is listed here.</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="c"># Makefile for mandelbrot GPU</span>

<span class="nv">CC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>clang
<span class="nv">CCFLAGS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>-fopenmp<span class="o">=</span>libomp<span class="w"> </span>-fopenmp-targets<span class="o">=</span>nvptx64-nvidia-cuda<span class="w"> </span>-Xopenmp-target<span class="o">=</span>nvptx64-nvidia-cuda<span class="w"> </span>-march<span class="o">=</span>sm_80

<span class="nf">all</span><span class="o">:</span><span class="w"> </span><span class="n">mandelbrot</span>

<span class="nf">mandelbrot</span><span class="o">:</span><span class="w"> </span><span class="n">mandelbrot</span>.<span class="n">o</span>
<span class="w">	</span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span><span class="k">$(</span>CCFLAGS<span class="k">)</span><span class="w"> </span>-g<span class="w"> </span>-o<span class="w"> </span><span class="nv">$@</span><span class="w"> </span>$^<span class="w"> </span>utils/lodepng.c

<span class="nf">mandelbrot.o</span><span class="o">:</span><span class="w"> </span><span class="n">mandelbrot</span>.<span class="n">c</span>
<span class="w">	</span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span><span class="k">$(</span>CCFLAGS<span class="k">)</span><span class="w"> </span>-g<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span><span class="nv">$@</span><span class="w"> </span>$^

<span class="nf">clean</span><span class="o">:</span>
<span class="w">	</span>@rm<span class="w"> </span>-rf<span class="w"> </span>*.o<span class="w"> </span>*~<span class="w"> </span>*#<span class="w"> </span><span class="k">$(</span>EXEC<span class="k">)</span><span class="w"> </span>*png<span class="w"> </span>mandelbrot
</pre></div>
</div>
</section>
<section id="compilation-process">
<h1>Compilation process<a class="headerlink" href="#compilation-process" title="Link to this heading"></a></h1>
<p>We briefly describe the syntax of the compilation process with the Clang compiler to implement the OpenMP offload targeting NVIDIA-GPUs on <a class="reference internal" href="../../hpc_machines/betzy.html#betzy"><span class="std std-ref">Betzy</span></a> platform. The syntax is given below:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">clang -fopenmp=libomp -fopenmp-targets=nvptx64-nvidia-cuda -Xopenmp-target=nvptx64-nvidia-cuda -march=sm_80 gpu_code.c</span>
</pre></div>
</div>
<p>Here the flag <code class="docutils literal notranslate"><span class="pre">-fopenmp</span></code> activates the OpenMP directives (i.e. #pragma omp). The option <code class="docutils literal notranslate"><span class="pre">-fopenmp-targets</span></code> is used to enable target <code class="docutils literal notranslate"><span class="pre">offloading</span></code> to <code class="docutils literal notranslate"><span class="pre">NVIDIA-GPUs</span></code> and the <code class="docutils literal notranslate"><span class="pre">-Xopenmp-target</span></code> flag enables options to be passed to the target offloading toolchain. Last, the flag <code class="docutils literal notranslate"><span class="pre">-march</span></code> specifies the name of the <code class="docutils literal notranslate"><span class="pre">NVIDIA</span> <span class="pre">GPU</span></code> architecture.</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Sigma2/NRIS. Text shared under CC-BY 4.0 license.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>